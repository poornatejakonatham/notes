<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Go Tutorial - Learn Go from the Basics with Code Examples]]></title><description><![CDATA[Go tutorial to help beginners get started with Go programming quickly. These tutorials cover the basic hello world program as well as advanced concepts such as concurrency and reflection. 
]]></description><link>https://golangbot.com/</link><generator>Ghost 0.11</generator><lastBuildDate>Sun, 30 Jan 2022 12:49:38 GMT</lastBuildDate><atom:link href="https://golangbot.com/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[MySQL Tutorial: Selecting Single and Multiple Rows]]></title><description><![CDATA[In this tutorial, we will learn how to select a single row as well as multiple rows from a MySQL table using Go.]]></description><link>https://golangbot.com/mysql-select-single-multiple-rows/</link><guid isPermaLink="false">59146271-82c2-482a-9dbc-6904fcfeaf4c</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sat, 16 Oct 2021 18:00:04 GMT</pubDate><content:encoded><![CDATA[<h4 id="mysqlseriesindex">MySQL Series Index</h4>

<p><a href="https://golangbot.com/connect-create-db-mysql/">Connecting to MySQL and creating a Database</a><br>
<a href="https://golangbot.com/mysql-create-table-insert-row/">Creating a Table and Inserting Rows</a><br>
<a href="https://golangbot.com/mysql-select-single-multiple-rows/">Selecting Single Row and Multiple rows</a><br>
Prepared statements - WIP <br>
Updating rows - WIP <br>
Deleting rows - WIP</p>

<p>Welcome to tutorial no. 3 in our MySQL tutorial series. In the <a href="https://golangbot.com/mysql-create-table-insert-row/">previous tutorial</a>, we discussed creating a table and inserting rows into the table. In this tutorial, we will learn how to select a single row as well as multiple rows from a table.</p>

<h3 id="selectingasinglerow">Selecting a single row</h3>

<p>The <code>product</code> table we created in the <a href="https://golangbot.com/mysql-create-table-insert-row/">previous tutorial</a> has three rows. Running <code>select * from product;</code> on the table returns the following rows.</p>

<p><img src="https://golangbot.com/content/images/2021/10/Screenshot-2021-10-16-at-6.54.44-PM.png" alt=""></p>

<p>In this section of the tutorial, we will write code to select a single row from this table. We will write a <a href="https://golangbot.com/functions/">function</a> that will return the product price when the product name is given as the input. The query to do this is provided below.</p>

<pre><code>select product_price from product where product_name = "iphone";  
</code></pre>

<p>The above query will return one row and will return the <code>product_price</code> column from that row. The above query will return <code>950</code></p>

<p>Now that we have the query ready, let's go ahead and code it.</p>

<p>The first step is to create a <a href="https://en.wikipedia.org/wiki/Prepared_statement" target="_"blank"">prepared statement</a>. Prepared statements are used to parametrize a SQL query so that the same query can be run with different arguments efficiently. It also prevents <a href="https://en.wikipedia.org/wiki/SQL_injection" target="_"blank"">sql injection</a>. </p>

<p>The template for the prepared statement is provided below.</p>

<pre><code>select product_price from product where product_name = ?  
</code></pre>

<p>We have replaced <code>iphone</code> with <code>?</code> to create the prepared statement template.</p>

<p>The next step is to create the prepared statement. This is done using the PrepareContext method.</p>

<pre><code class="language-go line-numbers">func selectPrice(db *sql.DB, productName string) (int, error) {  
    query := `select product_price from product where product_name = ?`
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    stmt, err := db.PrepareContext(ctx, query)
    if err != nil {
        log.Printf("Error %s when preparing SQL statement", err)
        return 0, err
    }
    defer stmt.Close()
    ...
}
</code></pre>

<p>We pass a context with a <code>5</code> second timeout to the <code>PrepareContext</code> method in line no. 5. This method returns a prepared statement. We defer closing the statement in line no. 10. </p>

<p>The next step is to execute this prepared statement. This is done using the QueryRowContext method.</p>

<pre><code class="language-go line-numbers">var price int  
row := stmt.QueryRowContext(ctx, productName)  
if err := row.Scan(&amp;price); err != nil {  
    return 0, err
}
</code></pre>

<p>The <code>QueryRowContext</code> method is called on the prepared statement <code>stmt</code>. This method takes a context and a variadic list of arguments as parameter. In our case, we have only one argument in the query which is the product name and we pass this as the argument to this method. </p>

<p>The <code>QueryRowContext</code> returns a single row. We then need to call <code>Scan</code> on the <code>row</code> to copy the columns returned by the query to the pointer passed to the <code>Scan</code> method. Here we pass an integer pointer in line no. 3 of the above code snippet to which the price will be stored. If the query returns more than one row, the <code>Scan</code> method will return only the first row and there will be no error. If there are no rows returned, <code>Scan</code> will return an error. We will discuss <a href="https://golangbot.com/error-handling/">error handling</a> in the next section. </p>

<p>The complete function is provided below.</p>

<pre><code class="language-go line-numbers">func selectPrice(db *sql.DB, productName string) (int, error) {  
    log.Printf("Getting product price")
    query := `select product_price from product where product_name = ?`
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    stmt, err := db.PrepareContext(ctx, query)
    if err != nil {
        log.Printf("Error %s when preparing SQL statement", err)
        return 0, err
    }
    defer stmt.Close()
    var price int
    row := stmt.QueryRowContext(ctx, productName)
    if err := row.Scan(&amp;price); err != nil {
        return 0, err
    }
    return price, nil
}
</code></pre>

<h3 id="errorhandling">Error handling</h3>

<p>The <code>Scan</code> method used in line no. 14 of the above function will return error <code>ErrNoRows</code> when no rows are returned by the query. Let's call our <code>selectPrice</code> function from <code>main</code> where will handle errors.</p>

<pre><code class="language-go line-numbers">func main() {  
...
    productName := "iphone"
    price, err := selectPrice(db, productName)
    switch {
    case err == sql.ErrNoRows:
        log.Printf("Product %s not found in DB", productName)
    case err != nil:
        log.Printf("Encountered err %s when fetching price from DB", err)
    default:
        log.Printf("Price of %s is %d", productName, price)
    }
}
</code></pre>

<p>We pass product name as <code>iphone</code> to <code>selectPrice</code> and then <a href="https://golangbot.com/switch/">switch case</a> on the error. If the error is of type <code>ErrNoRows</code> we print a message saying that the product is not found. In case of any other error, we print the error message. And in the <code>default</code> case we print the result. </p>

<p>This program will print</p>

<pre><code>Price of iphone is 950  
</code></pre>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="selectingmultiplerows">Selecting multiple rows</h3>

<p>In this section, we will learn how to select multiple rows from a table. We will write a function that will take minimum price and maximum price as parameters and return the name and price of the products that match the query.</p>

<p>The query that does that is provided below.</p>

<pre><code>select product_name, product_price from product where product_price &gt;= 900 &amp;&amp; product_price &lt;= 1000;  
</code></pre>

<p>The above query will return the name and price of all products whose prices fall between <code>900</code> and <code>1000</code>.</p>

<p>Most of the steps for selecting multiple rows are similar to selecting a single row which we discussed in the previous section. I have provided the complete function to select multiple rows below.</p>

<pre><code class="language-go line-numbers">func selectProductsByPrice(db *sql.DB, minPrice int, maxPrice int) ([]product, error) {  
    log.Printf("Getting products by price")
    query := `select product_name, product_price from product where product_price &gt;= ? &amp;&amp; product_price &lt;= ?;`
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    stmt, err := db.PrepareContext(ctx, query)
    if err != nil {
        log.Printf("Error %s when preparing SQL statement", err)
        return []product{}, err
    }
    defer stmt.Close()
    rows, err := stmt.QueryContext(ctx, minPrice, maxPrice)
    if err != nil {
        return []product{}, err
    }
    defer rows.Close() 
    var products = []product{}
    for rows.Next() {
        var prd product
        if err := rows.Scan(&amp;prd.name, &amp;prd.price); err != nil {
            return []product{}, err
        }
        products = append(products, prd)
    }
    if err := rows.Err(); err != nil {
        return []product{}, err
    }
    return products, nil
}
</code></pre>

<p>Similar to the previous section, we first created a prepared statement in line no. 6 of the above function. After that we call <code>QueryContext</code> method on the prepared statement <code>stmt</code> in line no. 12. This method will return the list of rows selected by the query. We defer closing the rows in line no. 16.</p>

<p>After getting the row list, we call <code>Next</code> method on <code>rows</code> in line no. 18. This prepares the result for reading using the <code>Scan</code> method. If there is any error when calling <code>Next()</code>, it will return <code>false</code> and the <a href="https://golangbot.com/loops/">for loop</a> will terminate. In case of error, <code>Err()</code> method on <code>rows</code> will return a non <code>nil</code> value and we need to call that to find out if there was any error when <code>Next()</code> was called. This is done in line no. 25.</p>

<p>If there is no error when fetching the rows, <code>rows</code> is closed automatically by the <code>Next()</code> method call in line no. 18. If there is any error, it is necessary to call <code>Close</code> explicitly. Since the call to <code>Close()</code> is idempotent, it's ok to call it twice i.e once during the successfully <code>Next()</code> call and again during defer in line no. 16. Hence we have deferred the rows close in line no. 16.</p>

<p>In line no. 19 we create <code>prd</code> of type <code>product</code> to store the result. </p>

<p>In case you don't remember, <code>product</code> struct has the following fields.</p>

<pre><code class="language-go line-numbers">type product struct {  
    name  string
    price int
}
</code></pre>

<p>In line no. 20, the result columns are copied to the <code>name</code> and <code>price</code> fields of the <code>prd</code> struct and in line no. 23, <code>prd</code> is appended to the <code>products</code> <a href="https://golangbot.com/arrays-and-slices/#slices">slice</a>. </p>

<p><code>products</code> is returned in line no. 28.</p>

<p>The next step is to call this function from main.</p>

<pre><code class="language-go line-numbers">func main() {  
...
    minPrice := 900
    maxPrice := 1000
    products, err := selectProductsByPrice(db, minPrice, maxPrice)
    if err != nil {
        log.Printf("Error %s when selecting product by price", err)
        return
    }
    for _, product := range products {
        log.Printf("Name: %s Price: %d", product.name, product.price)
    }
</code></pre>

<p>We pass <code>900</code> and <code>1000</code> as the minimum and maximum price to the <code>selectProductsByPrice</code> function in line no. 5. </p>

<p>If there is any error, we return after printing the error.</p>

<p>If there is no error, the name and price of the products matching the query are printed in line no. 11.</p>

<p>This program will print,</p>

<pre><code>2021/10/16 21:10:52 Getting products by price  
2021/10/16 21:10:52 Name: iphone Price: 950  
2021/10/16 21:10:52 Name: Galaxy Price: 990  
</code></pre>

<p>This brings us to the end of this tutorial. Please share your valuable feedback in the comments. </p>

<p>The entire code is available at <a href="https://github.com/golangbot/mysqltutorial/blob/master/select/main.go" target="_"blank"">https://github.com/golangbot/mysqltutorial/blob/master/select/main.go</a></p>

<p>If you would like to advertise on this website, hire me, or if you have any other development requirements, please email to <em>naveen[at]golangbot[dot]com</em>.</p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>

<p><strong>Previous tutorial - <a href="https://golangbot.com/mysql-create-table-insert-row/">Creating a Table and Inserting Rows</a></strong></p>]]></content:encoded></item><item><title><![CDATA[MySQL Tutorial: Creating a Table and Inserting Rows]]></title><description><![CDATA[Learn how to create a table and insert rows in MySQL using Go. This tutorial also covers multiple row insertion.]]></description><link>https://golangbot.com/mysql-create-table-insert-row/</link><guid isPermaLink="false">052c6193-90dc-4868-a1a8-ce6474f44b39</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sun, 07 Mar 2021 00:58:00 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 2 in our MySQL tutorial series. In the <a href="https://golangbot.com/connect-create-db-mysql/">first tutorial</a>, we discussed how to <a href="https://golangbot.com/connect-create-db-mysql/">connect to MySQL and create a database</a>. In this tutorial, we will learn how to create a table and insert records into that table.</p>

<h4 id="mysqlseriesindex">MySQL Series Index</h4>

<p><a href="https://golangbot.com/connect-create-db-mysql/">Connecting to MySQL and creating a Database</a><br>
<a href="https://golangbot.com/mysql-create-table-insert-row/">Creating a Table and Inserting Rows</a><br>
<a href="https://golangbot.com/mysql-select-single-multiple-rows/">Selecting single and multiple rows</a><br>
Prepared statements - WIP <br>
Updating rows - WIP <br>
Deleting rows - WIP</p>

<h3 id="createtable">Create Table</h3>

<p>We will be creating a table named <code>product</code> with the fields <code>product_id</code>, <code>product_name</code>, <code>product_price</code>, <code>created_at</code> and <code>updated_at</code>.</p>

<p>The MySQL query to create this table is provided below,</p>

<pre><code>CREATE TABLE IF NOT EXISTS product(product_id int primary key auto_increment, product_name text, product_price int, created_at datetime default CURRENT_TIMESTAMP, updated_at datetime default CURRENT_TIMESTAMP)  
</code></pre>

<p><em>product_id</em> is an auto incremented <code>int</code> and it serves as the primary key. The default values of <code>created_at</code> and <code>updated_at</code> is set as the current timestamp. Now that we have query, let's convert it into Go code and create our table.</p>

<p>The <a href="https://golang.org/pkg/database/sql/#DB.ExecContext" target="_"blank"">ExecContext</a> method of the DB package executes any query that doesn't return any rows. In our case, the create table query doesn't return any rows and hence we will use the <code>ExecContext()</code> context method to create our table.</p>

<p>Let's be a responsible developer and create a context with a timeout so that the create table query times out in case of any network partition or runtime errors.</p>

<pre><code class="language-go line-numbers">query := `CREATE TABLE IF NOT EXISTS product(product_id int primary key auto_increment, product_name text,  
        product_price int, created_at datetime default CURRENT_TIMESTAMP, updated_at datetime default CURRENT_TIMESTAMP)`

ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)  
defer cancelfunc()  
</code></pre>

<p>In the above code, we have created a context with a 5 second timeout. Let's go ahead and use this context in the <code>ExecContext()</code> method.</p>

<pre><code class="language-go line-numbers">res, err := db.ExecContext(ctx, query)  
if err != nil {  
    log.Printf("Error %s when creating product table", err)
    return err
}
</code></pre>

<p>We pass the created context and the MySQL query as parameters to the <code>ExecContext</code> method and return errors if any. The <code>db</code> is the database connection pool that was created in the previous tutorial <a href="https://golangbot.com/connect-create-db-mysql/">https://golangbot.com/connect-create-db-mysql/</a>. Please go through it to understand how to connect to MySQL and create a connection pool.</p>

<p>Now the table is created successfully. The result set returned from the call to <code>ExecContext()</code> contains a method that returns the number of rows affected. The create table statement doesn't affect any rows but still, let's check this out by calling the <code>res.RowsAffected()</code> method. </p>

<pre><code class="language-go line-numbers">rows, err := res.RowsAffected()  
    if err != nil {
        log.Printf("Error %s when getting rows affected", err)
        return err
    }
log.Printf("Rows affected when creating table: %d", rows)  
</code></pre>

<p>The above code will print <code>Rows affected when creating table: 0</code> since <code>create table</code> doesn't affect any rows.</p>

<p>The entire code is provided below.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"

    _ "github.com/go-sql-driver/mysql"
)

const (  
    username = "root"
    password = "naveenr123"
    hostname = "127.0.0.1:3306"
    dbname   = "ecommerce"
)

func dsn(dbName string) string {  
    return fmt.Sprintf("%s:%s@tcp(%s)/%s", username, password, hostname, dbName)
}

func dbConnection() (*sql.DB, error) {  
    db, err := sql.Open("mysql", dsn(""))
    if err != nil {
        log.Printf("Error %s when opening DB\n", err)
        return nil, err
    }
    //defer db.Close()

    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    res, err := db.ExecContext(ctx, "CREATE DATABASE IF NOT EXISTS "+dbname)
    if err != nil {
        log.Printf("Error %s when creating DB\n", err)
        return nil, err
    }
    no, err := res.RowsAffected()
    if err != nil {
        log.Printf("Error %s when fetching rows", err)
        return nil, err
    }
    log.Printf("rows affected %d\n", no)

    db.Close()
    db, err = sql.Open("mysql", dsn(dbname))
    if err != nil {
        log.Printf("Error %s when opening DB", err)
        return nil, err
    }
    //defer db.Close()

    db.SetMaxOpenConns(20)
    db.SetMaxIdleConns(20)
    db.SetConnMaxLifetime(time.Minute * 5)

    ctx, cancelfunc = context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    err = db.PingContext(ctx)
    if err != nil {
        log.Printf("Errors %s pinging DB", err)
        return nil, err
    }
    log.Printf("Connected to DB %s successfully\n", dbname)
    return db, nil
}

func createProductTable(db *sql.DB) error {  
    query := `CREATE TABLE IF NOT EXISTS product(product_id int primary key auto_increment, product_name text, 
        product_price int, created_at datetime default CURRENT_TIMESTAMP, updated_at datetime default CURRENT_TIMESTAMP)`
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    res, err := db.ExecContext(ctx, query)
    if err != nil {
        log.Printf("Error %s when creating product table", err)
        return err
    }
    rows, err := res.RowsAffected()
    if err != nil {
        log.Printf("Error %s when getting rows affected", err)
        return err
    }
    log.Printf("Rows affected when creating table: %d", rows)
    return nil
}

func main() {  
    db, err := dbConnection()
    if err != nil {
        log.Printf("Error %s when getting db connection", err)
        return
    }
    defer db.Close()
    log.Printf("Successfully connected to database")
    err = createProductTable(db)
    if err != nil {
        log.Printf("Create product table failed with error %s", err)
        return
    }
}
</code></pre>

<p>I have included the code to connect to MySQL and create a database from the <a href="https://golangbot.com/connect-create-db-mysql/">previous tutorial</a> inside the  <code>dbConnection()</code> function. The only change from the previous tutorial is that the defer statements in line no. 30 and line no. 52 are commented since we do not want the database to be closed immediately after returning from this function.</p>

<p>The <code>main()</code> function creates a new DB connection pool in line no. 89 and passes that to the <code>createProductTable</code> function in line no. 95. We defer the database close in line no. 93 so that the connection to the DB is closed when the program terminates. Run this program and you can see the following output,</p>

<pre><code>2020/10/25 20:30:51 rows affected 1  
2020/10/25 20:30:51 Connected to DB ecommerce successfully  
2020/10/25 20:30:51 Successfully connected to database  
2020/10/25 20:30:51 Rows affected when creating table: 0  
</code></pre>

<p>To verify whether the table has been created successfully, you can run <code>desc product;</code> in <a href="https://downloads.mysql.com/archives/query/" target="_"blank"">MySQL query browser</a> and you can see that it returns the table schema.</p>

<p><img src="https://golangbot.com/content/images/2020/10/describe-product-table.png" alt=""></p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="insertrow">Insert Row</h3>

<p>The next step is to insert rows into the <code>product</code> table we just created. The query to insert a row into the product table is provided below,</p>

<pre><code>INSERT INTO product(product_name, product_price) VALUES ("iPhone", 800);  
</code></pre>

<p>Let's discuss how to use the above query in Go and insert rows into the table.</p>

<p>Let's first create a product struct to represent our product.</p>

<pre><code class="language-go line-numbers">type product struct {  
    name      string
    price     int
}
</code></pre>

<p>The second step is to create a <a href="https://en.wikipedia.org/wiki/Prepared_statement" target="_"blank"">prepared statement</a>. Prepared statements are used to parametrize a SQL query so that the same query can be run with different arguments efficiently. It also helps prevent <a href="https://en.wikipedia.org/wiki/SQL_injection" target="_"blank"">sql injection</a>. </p>

<p>In our case, the parameters to the query are <code>product_name</code> and <code>product_price</code>. The way to create a prepared statement template is to replace the parameters with question mark <code>?</code>. The prepared statement template of the following query</p>

<pre><code>INSERT INTO product(product_name, product_price) VALUES ("iPhone", 800);  
</code></pre>

<p>is  </p>

<pre><code>INSERT INTO product(product_name, product_price) VALUES (?, ?);  
</code></pre>

<p>You can see that <code>"iPhone"</code> and <code>800</code> are replaced with question marks.</p>

<pre><code class="language-go line-numbers">func insert(db *sql.DB, p product) error {  
    query := "INSERT INTO product(product_name, product_price) VALUES (?, ?)"
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    stmt, err := db.PrepareContext(ctx, query)
    if err != nil {
    log.Printf("Error %s when preparing SQL statement", err)
    return err
    }
    defer stmt.Close()
}
</code></pre>

<p>Line no. 2 of the above code has the prepared statement template. In line no. 5, we create a prepared statement for our insert query using this template. As usual, we use a context with a timeout to handle network errors. The statement should be closed after use. So in the next line we defer the statement close.</p>

<p>The next step is to pass the necessary parameters to the prepared statement and execute it.</p>

<pre><code class="language-go line-numbers">res, err := stmt.ExecContext(ctx, p.name, p.price)  
if err != nil {  
    log.Printf("Error %s when inserting row into products table", err)
    return err
}
rows, err := res.RowsAffected()  
if err != nil {  
    log.Printf("Error %s when finding rows affected", err)
    return err
}
log.Printf("%d products created ", rows)  
return nil  
</code></pre>

<p>The prepared statement expects two arguments namely the product name and the product price. The <code>ExecContext</code> method accepts a variadic list of <a href="https://golangbot.com/interfaces-part-1/">interface{}</a> arguments. The number of variadic arguments passed to it should match the number of question marks <code>?</code> in the prepared statement template, else there will be a runtime error <code>Column count doesn't match value count at row 1 when preparing SQL statement</code>. </p>

<p>In our case, there are two question marks in the template and hence in the above code snippet, in line no. 1, we pass the two parameters product name and price to the <a href="https://golang.org/pkg/database/sql/#Stmt.ExecContext" target="_"blank"">ExecContext</a> method.</p>

<p>The entire <code>insert</code> function is provided below.</p>

<pre><code class="language-go line-numbers">func insert(db *sql.DB, p product) error {  
    query := "INSERT INTO product(product_name, product_price) VALUES (?, ?)"
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    stmt, err := db.PrepareContext(ctx, query)
    if err != nil {
        log.Printf("Error %s when preparing SQL statement", err)
        return err
    }
    defer stmt.Close()
    res, err := stmt.ExecContext(ctx, p.name, p.price)
    if err != nil {
        log.Printf("Error %s when inserting row into products table", err)
        return err
    }
    rows, err := res.RowsAffected()
    if err != nil {
        log.Printf("Error %s when finding rows affected", err)
        return err
    }
    log.Printf("%d products created ", rows)
    return nil
}
</code></pre>

<p>Please add the following code to the end of <code>main</code> function to call the <code>insert</code> function.</p>

<pre><code class="language-go line-numbers">func main() {  
...

p := product{  
        name:  "iphone",
        price: 950,
    }
err = insert(db, p)  
if err != nil {  
    log.Printf("Insert product failed with error %s", err)
    return
    }
}
</code></pre>

<p>If everything goes well, the program will print <code>1 products created</code></p>

<p>You can check that the product has been inserted successfully by running <code>select * from product;</code> and you can see the following output in MySQL query browser.</p>

<p><img src="https://golangbot.com/content/images/2020/10/MySQL-Insert-Query.png" alt=""></p>

<h3 id="lastinsertedid">Last Inserted ID</h3>

<p>There might be a need to get the last inserted ID of an insert query with auto increment primary key. In our case, the <code>product_id</code> is an auto incremented int primary key. We might need the last inserted product id to reference in other tables. Say, we have a supplier table and would like to map suppliers once a new product is created. In this case, fetching the last inserted ID is essential. The <code>LastInsertId</code> method of the result set can be used to fetch this ID. Add the following code to the end of the <code>insert</code> function before <code>return nil</code>.</p>

<pre><code class="language-go line-numbers">func insert(db *sql.DB, p product) error {  
...

    prdID, err := res.LastInsertId()
    if err != nil {
    log.Printf("Error %s when getting last inserted product",     err)
    return err
    }
    log.Printf("Product with ID %d created", prdID)
    return nil
}
</code></pre>

<p>When the program is run with the above code added, the line <code>Product with ID 2 created</code> will be printed. We can see that the ID of the last inserted product is <code>2</code>.</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="insertmultiplerows">Insert Multiple Rows</h3>

<p>Let's take our insert statement to the next level and try to insert multiple rows using a single query. </p>

<p>The MySQL syntax for inserting multiple rows is provided below</p>

<pre><code>insert into product(product_name, product_price) values ("Galaxy","990"),("iPad","500")  
</code></pre>

<p>The different rows to be inserted are separated by commas. Let's see how to achieve this using Go. </p>

<p>The logic is to generate the <code>("Galaxy","990"),("iPad","500")</code> after the <code>values</code> part of the query dynamically based on the number of products needed to be inserted. In this case, two products namely <code>Galaxy</code> and <code>iPad</code> have to be inserted. So there is a need to generate a prepared statement template of the following format.</p>

<pre><code>insert into product(product_name, product_price) values (?,?),(?,?)  
</code></pre>

<p>Let's write the function to do this right away.</p>

<pre><code class="language-go line-numbers">func multipleInsert(db *sql.DB, products []product) error {  
    query := "INSERT INTO product(product_name, product_price) VALUES "
    var inserts []string
    var params []interface{}
    for _, v := range products {
        inserts = append(inserts, "(?, ?)")
        params = append(params, v.name, v.price)
    }
}
</code></pre>

<p>We iterate over the <code>products</code> parameter passed to the function and for each product we append <code>(?, ?)</code> to the <code>inserts</code> <a href="https://golangbot.com/arrays-and-slices/">slice</a> in line no. 6. In the same <code>for</code> loop we append the actual parameters that should substitute the question marks <code>?</code> to the <code>params</code> slice. <br>
There is one more step remaining before the prepared statement template is ready. The <code>inserts</code> slice is of length 2 and it contains <code>(?, ?)</code> and <code>(?, ?)</code>. These two have to be concatenated with a comma in the middle. The <a href="https://golang.org/pkg/strings/#Join" target="_"blank"">Join</a> can be used to do that. It takes a string slice and a separator as parameters and joins the elements of the slice with the separator.</p>

<pre><code class="language-go line-numbers">queryVals := strings.Join(inserts, ",")  
query = query + queryVals  
</code></pre>

<p><em>queryVals</em> now contains <code>(?, ?),(?, ?)</code>. We then concatenate <code>query</code> and <code>queryVals</code> to generate the final prepared statement template <code>INSERT INTO product(product_name, product_price) VALUES (?, ?),(?, ?)</code>. </p>

<p>The remaining code is similar to the single row insert function. Here is the full function.</p>

<pre><code class="language-go line-numbers">func multipleInsert(db *sql.DB, products []product) error {  
    query := "INSERT INTO product(product_name, product_price) VALUES "
    var inserts []string
    var params []interface{}
    for _, v := range products {
        inserts = append(inserts, "(?, ?)")
        params = append(params, v.name, v.price)
    }
    queryVals := strings.Join(inserts, ",")
    query = query + queryVals
    log.Println("query is", query)
    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    stmt, err := db.PrepareContext(ctx, query)
    if err != nil {
        log.Printf("Error %s when preparing SQL statement", err)
        return err
    }
    defer stmt.Close()
    res, err := stmt.ExecContext(ctx, params...)
    if err != nil {
        log.Printf("Error %s when inserting row into products table", err)
        return err
    }
    rows, err := res.RowsAffected()
    if err != nil {
        log.Printf("Error %s when finding rows affected", err)
        return err
    }
    log.Printf("%d products created simulatneously", rows)
    return nil
}
</code></pre>

<p>The one difference which you could see is in line no. 20. We pass the slice as a <a href="https://golangbot.com/variadic-functions/">variadic argument</a> since <code>ExecContext</code> expects a variadic argument. The remaining code is the same.</p>

<p>Add the following lines to the end of the main function to call the <code>multipleInsert</code> function.</p>

<pre><code class="language-go line-numbers">func main() {  
...

p1 := product{  
    name:  "Galaxy",
    price: 990,
}
p2 := product{  
    name:  "iPad",
    price: 500,
}
err = multipleInsert(db, []product{p1, p2})  
if err != nil {  
    log.Printf("Multiple insert failed with error %s", err)
    return
}
</code></pre>

<p>On running the program you can see </p>

<pre><code>query is INSERT INTO product(product_name, product_price) VALUES (?, ?),(?, ?)  
2 products created simultaneously  
</code></pre>

<p>printed. 
On querying the table, it can be confirmed that two products are inserted. </p>

<p>The entire code is available in at <a href="https://github.com/golangbot/mysqltutorial/blob/master/insert/main.go" target="_"blank"">https://github.com/golangbot/mysqltutorial/blob/master/insert/main.go</a></p>

<p>This brings us to an end of this tutorial. Please leave your comments and feedback.</p>

<p>If you would like to advertise on this website, hire me, or if you have any other development requirements please email to <em>naveen[at]golangbot[dot]com</em>.</p>

<p><strong>Previous tutorial - <a href="https://golangbot.com/connect-create-db-mysql/">Connecting to MySQL and Creating a DB using Go</a><br>
Next tutorial - <a href="https://golangbot.com/mysql-select-single-multiple-rows/">Selecting Single and Multiple Rows</a></strong></p>]]></content:encoded></item><item><title><![CDATA[MySQL Tutorial: Connecting to MySQL and Creating a DB using Go]]></title><description><![CDATA[Learn how to connect to MySQL and create a database using the database/sql package. This tutorial also deals with DB connection pooling in Go.]]></description><link>https://golangbot.com/connect-create-db-mysql/</link><guid isPermaLink="false">784cbfd4-fb23-468d-ab74-c94d57b25af7</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Mon, 05 Oct 2020 19:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 1 in our MySQL tutorial series. In this tutorial, we will connect to MySQL and create a database. We will also ping the DB to ensure the connection is established properly.</p>

<h4 id="mysqlseriesindex">MySQL Series Index</h4>

<p><a href="https://golangbot.com/connect-create-db-mysql/">Connecting to MySQL and creating a Database</a><br>
<a href="https://golangbot.com/mysql-create-table-insert-row/">Creating a Table and Inserting Rows</a><br>
<a href="https://golangbot.com/mysql-select-single-multiple-rows/">Selecting single and multiple rows</a><br>
Prepared statements - WIP <br>
Updating rows - WIP <br>
Deleting rows - WIP</p>

<h3 id="importingthemysqldriver">Importing the MySQL driver</h3>

<p>The first step in creating the MySQL database is to download the MySQL driver <a href="https://golangbot.com/go-packages/">package</a> and import it into our application.</p>

<p>Let's create a folder for our app and then download the MySQL package.</p>

<p>I have created a folder in the <code>Documents</code> directory. Please feel free to create it wherever you like.  </p>

<pre><code>mkdir ~/Documents/mysqltutorial  
cd ~/Documents/mysqltutorial  
</code></pre>

<p>After creating the directory, let's initialize a go module for the project. </p>

<pre><code>go mod init github.com/golangbot/mysqltutorial  
</code></pre>

<p>The above command initializes a module named <code>github.com/golangbot/mysqltutorial</code></p>

<p>The next step is to download the MySql driver. Run the following command to download the MySQL driver package.</p>

<pre><code>go get github.com/go-sql-driver/mysql  
</code></pre>

<p>Let's write a program to import the MySQL driver we just downloaded.</p>

<p>Create a file named <code>main.go</code> with the following contents.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "database/sql"

    _ "github.com/go-sql-driver/mysql"
)
</code></pre>

<h3 id="useofblankidentifier_whenimportingthedriver">Use of blank identifier _ when importing the driver</h3>

<p>The <code>"database/sql"</code> package provides generic <a href="https://golangbot.com/interfaces-part-1/">interfaces</a> for accessing the MySQL database. It contains the types needed to manage the MySQL DB. </p>

<p>In the next line, we import <code>_ "github.com/go-sql-driver/mysql"</code> prefixed with an underscore (called as a blank identifier). What does this mean? This means we are importing the MySQL driver package for its side effect and we will not use it explicitly anywhere in our code. <strong>When a package is imported prefixed with a blank identifier, the init function of the package will be called. Also, the Go compiler will not complain if the package is not used anywhere in the code.</strong></p>

<p>That's all fine, but why is this needed?</p>

<p>The reason is any SQL driver must be registered by calling the <a href="https://golang.org/pkg/database/sql/#Register" target="_"blank"">Register</a> function before it can be used. If we take a look at the source code of the MySQL driver, in line <a href="https://github.com/go-sql-driver/mysql/blob/b66d043e6c8986ca01241b990326db395f9c0afd/driver.go#L83">https://github.com/go-sql-driver/mysql/blob/b66d043e6c8986ca01241b990326db395f9c0afd/driver.go#L83</a> we can see the following <code>init</code> function</p>

<pre><code class="language-go line-numbers">func init() {  
    sql.Register("mysql", &amp;MySQLDriver{})
}
</code></pre>

<p>The above function registers the SQL driver named <code>mysql</code>. When we import the package prefixed with the blank identifier <code>_ "github.com/go-sql-driver/mysql"</code>, this <code>init</code> function is called and the driver is available for use. Perfect ðŸ˜ƒ. Just what we wanted. </p>

<h3 id="connectingandcreatingthedatabase">Connecting and Creating the Database</h3>

<p>Now that we have registered the driver successfully, the next step is to connect to MySQL and create the database. </p>

<p>Let's define <a href="https://golangbot.com/constants/">constants</a> for our DB credentials.</p>

<pre><code class="language-go line-numbers">const (  
    username = "root"
    password = "password"
    hostname = "127.0.0.1:3306"
    dbname   = "ecommerce"
)
</code></pre>

<p>Please replace the above values with your credentials.</p>

<p>The DB can be opened by using <a href="https://golang.org/pkg/database/sql/#Open" target="_"blank"">Open</a> function of the sql package.  This function takes two parameters, the driver name, and the data source name(DSN). As we have already discussed, the driver name is <code>mysql</code>. The DSN is of the following format</p>

<pre><code>username:password@protocol(address)/dbname?param=value  
</code></pre>

<p>Let's write a small function that will return us this DSN when the database name is passed as a parameter.</p>

<pre><code class="language-go line-numbers">func dsn(dbName string) string {  
    return fmt.Sprintf("%s:%s@tcp(%s)/%s", username, password, hostname, dbName)
}
</code></pre>

<p>The above <a href="https://golangbot.com/functions/">function</a> returns a DSN for the <code>dbName</code> passed. The <code>dbName</code> is optional and it can be empty. For example, if <code>ecommerce</code> is passed, it will return <code>root:password@tcp(127.0.0.1:3306)/ecommerce</code></p>

<p>Since we are actually creating the DB here and do not want to connect an existing DB, an empty <code>dbName</code> will be passed to the <code>dsn</code> function.</p>

<pre><code class="language-go line-numbers">func main() {  
    db, err := sql.Open("mysql", dsn(""))
    if err != nil {
        log.Printf("Error %s when opening DB\n", err)
        return
    }
    defer db.Close()
}
</code></pre>

<p>Please ensure that the user has access rights to create the DB. The above lines of code open and return a connection to the database. The database connection is closed when the function returns using <a href="https://golangbot.com/defer/">defer</a>.</p>

<p>After establishing a connection to the DB, the next step is to create the DB. The following code does that.</p>

<pre><code class="language-go line-numbers">ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)  
defer cancelfunc()  
res, err := db.ExecContext(ctx, "CREATE DATABASE IF NOT EXISTS "+dbname)  
if err != nil {  
    log.Printf("Error %s when creating DB\n", err)
    return
}
no, err := res.RowsAffected()  
if err != nil {  
    log.Printf("Error %s when fetching rows", err)
    return
}
log.Printf("rows affected %d\n", no)  
</code></pre>

<p>After opening the database, we use the <a href="https://golang.org/pkg/database/sql/#DB.ExecContext" target="_"blank"">ExecContext</a>  method to create the database. This <a href="https://golangbot.com/methods/">method</a> is used to execute a query without returning any rows. Since we are creating a DB, it returns no rows, and <code>ExecContext</code> can be used to create the database. Being a responsible developer, we pass a context with a timeout of 5 seconds to ensure that the control doesn't get stuck when creating the DB in case there is any network error or any other error in the DB. <code>cancelfunc</code> is only needed when we want to cancel the context before it times out. There is no use of it here, hence we just defer the <code>cancelfunc</code> call.</p>

<p>The <code>ExecContext</code> call returns a <a href="https://golang.org/pkg/database/sql/#Result" target="_"blank"">result</a> type and an error. We can check the number of rows affected by the query by calling the <code>RowsAffected()</code> method. The above code creates a database named <code>ecommerce</code>.</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="understandingconnectionpool">Understanding Connection Pool</h3>

<p>The next step after creating the DB is to connect to it and start executing queries. In other programming languages, you might do this by running the <code>use ecommerce</code> command to select the database and start executing queries. This can be done in Go by using the code <code>db.ExecContext("USE ecommerce")</code>. </p>

<p>While this might seem to be a logical way to proceed, this leads to unexpected runtime errors in Go. Let's understand the reason behind this.</p>

<p>When we first executed <code>sql.Open("mysql", dsn(""))</code>, the <a href="https://golang.org/pkg/database/sql/#DB" target="_"blank"">DB</a> returned is actually a pool of underlying DB connections. The sql package takes care of maintaining the pool, creating and freeing connections automatically. This DB is also safe to be concurrently accessed by multiple <a href="https://golangbot.com/goroutines/">Goroutines</a>. </p>

<p>Since <code>DB</code> is a connection pool, if we execute <code>use ecommerce</code> on <code>DB</code>, it will be run on only one of the DB connections in the pool. When we execute another query on <code>DB</code>, we might end up running the query on some other connection in the pool on which <code>use ecommerce</code> was not executed. This will lead to the error <code>Error Code: 1046. No database selected</code>.</p>

<p>The solution is simple. We close the existing connection to the DB which we created without specifying a DB name and open a new connection with the DB name <code>ecommerce</code> which was just created.</p>

<pre><code class="language-go line-numbers">db.Close()  
db, err = sql.Open("mysql", dsn(dbname))  
if err != nil {  
    log.Printf("Error %s when opening DB", err)
    return
}
defer db.Close()  
</code></pre>

<p>In the above lines, we close the existing connection and open a new connection to the DB. This time we specify the DB name <code>ecommerce</code> in line no. 2 when opening a connection to the database. Now we have a connection pool connected to the <code>ecommerce</code> DB ðŸ˜ƒ.</p>

<h3 id="connectionpooloptions">Connection Pool Options</h3>

<p>There are few important connection pool options to be set to ensure that  network partitions and other runtime errors that may occur with our DB connections are handled properly.</p>

<h4 id="setmaxopenconns">SetMaxOpenConns</h4>

<p>This option is used to set the maximum number of open connections that are allowed from our application. It's better to set this to ensure that our application doesn't utilize all available connections to MySQL and starve other applications. </p>

<p>The  maximum connections for a MySQL Server can be determined by running the folllowing query</p>

<pre><code>show variables like 'max_connections';  
</code></pre>

<p>It returns the following output in my case. <code>151</code> is the default maximum connections allowed. You can change it to a different value according to your requirement. <br>
<img src="https://golangbot.com/content/images/2020/10/mysql-max-connections.png" alt=""></p>

<p><em>151</em> is the maximum connections allowed for this entire MySQL server which may include other applications accessing the same DB and also access to other databases if any exist.</p>

<p>Ensure that you set a value lower than <code>max_connections</code> so that other applications and databases are not starved. I am using <code>20</code>. Please feel free to change it according to your requirement.</p>

<pre><code class="language-go">db.SetMaxOpenConns(20)  
</code></pre>

<h4 id="setmaxidleconns">SetMaxIdleConns</h4>

<p>This option limits the maximum idle connections. The number of idle connections in the connection pool is controlled by this setting.</p>

<pre><code class="language-go">db.SetMaxIdleConns(20)  
</code></pre>

<h4 id="setconnmaxlifetime">SetConnMaxLifetime</h4>

<p>It's quite common for connections to become unusable because of a number of reasons. For instance, there might be a firewall or middleware that terminates idle connections. This option ensures that the driver closes the idle connection properly before it is terminated by a firewall or middleware.</p>

<pre><code class="language-go">db.SetConnMaxLifetime(time.Minute * 5)  
</code></pre>

<p>Please feel free to change the above options based on your requirement.</p>

<h3 id="pingingthedb">Pinging the DB</h3>

<p>The <code>Open</code> function call doesn't make an actual connection to the DB. It just validates whether the DSN is correct. The <a href="https://golang.org/pkg/database/sql/#DB.PingContext" target="_"blank"">PingContext()</a> method must be called to verify the actual connection to the database. It pings the DB and verifies the connection.</p>

<pre><code class="language-go line-numbers">ctx, cancelfunc = context.WithTimeout(context.Background(), 5*time.Second)  
defer cancelfunc()  
err = db.PingContext(ctx)  
if err != nil {  
    log.Printf("Errors %s pinging DB", err)
    return
}
log.Printf("Connected to DB %s successfully\n", dbname)  
</code></pre>

<p>We create a context with a 5 second timeout to ensure that the control doesn't get stuck when pinging the DB in case there is a network error or any other error.  </p>

<p>The full code is provided below.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"

    _ "github.com/go-sql-driver/mysql"
)

const (  
    username = "root"
    password = "password"
    hostname = "127.0.0.1:3306"
    dbname   = "ecommerce"
)

func dsn(dbName string) string {  
    return fmt.Sprintf("%s:%s@tcp(%s)/%s", username, password, hostname, dbName)
}

func main() {  
    db, err := sql.Open("mysql", dsn(""))
    if err != nil {
        log.Printf("Error %s when opening DB\n", err)
        return
    }
    defer db.Close()

    ctx, cancelfunc := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    res, err := db.ExecContext(ctx, "CREATE DATABASE IF NOT EXISTS "+dbname)
    if err != nil {
        log.Printf("Error %s when creating DB\n", err)
        return
    }
    no, err := res.RowsAffected()
    if err != nil {
        log.Printf("Error %s when fetching rows", err)
        return
    }
    log.Printf("rows affected %d\n", no)

    db.Close()
    db, err = sql.Open("mysql", dsn(dbname))
    if err != nil {
        log.Printf("Error %s when opening DB", err)
        return
    }
    defer db.Close()

    db.SetMaxOpenConns(20)
    db.SetMaxIdleConns(20)
    db.SetConnMaxLifetime(time.Minute * 5)

    ctx, cancelfunc = context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelfunc()
    err = db.PingContext(ctx)
    if err != nil {
        log.Printf("Errors %s pinging DB", err)
        return
    }
    log.Printf("Connected to DB %s successfully\n", dbname)
}
</code></pre>

<p>Running the above code will print</p>

<pre><code>2020/08/11 19:17:44 rows affected 1  
2020/08/11 19:17:44 Connected to DB ecommerce successfully  
</code></pre>

<p>That's about it for connecting to MySQL and creating a DB.</p>

<p>Please leave your comments and feedback.</p>

<p>If you would like to advertise on this website, hire me, or if you have any other development requirements please email to <em>naveen[at]golangbot[dot]com</em>.</p>

<p><strong>Next tutorial - <a href="https://golangbot.com/mysql-create-table-insert-row/">Creating a Table and Inserting Rows</a></strong></p>]]></content:encoded></item><item><title><![CDATA[WebAssembly: DOM Access and Error Handling]]></title><description><![CDATA[This tutorial deals with how to access the browser's DOM from Go using JavaScript mapping functions. Also learn how to handle errors returned from Go in JavaScript.]]></description><link>https://golangbot.com/go-webassembly-dom-access/</link><guid isPermaLink="false">fec542b9-74b4-4f5c-b5c7-6d6b84864523</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Tue, 23 Jun 2020 18:45:15 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 2 of our WebAssembly tutorial series. </p>

<h3 id="seriesindex">Series Index</h3>

<p><a href="https://golangbot.com/webassembly-using-go/">Introduction to WebAssembly Using Go</a><br>
<a href="https://golangbot.com/go-webassembly-dom-access/">Accessing DOM from Go using Javascript</a></p>

<p>In the <a href="https://golangbot.com/webassembly-using-go/">first tutorial</a> of this tutorial series, we created and exposed a function from Go and called it using JavaScript. I highly recommend reading the first part <a href="https://golangbot.com/webassembly-using-go/">https://golangbot.com/webassembly-using-go/</a> if you have not read it yet.</p>

<p>In this tutorial, we will develop a UI for our application, handle errors, and also manipulate the DOM of the browser from Go.</p>

<h3 id="creatingtheuiandcallingthewasmfunction">Creating the UI and calling the wasm function</h3>

<p>Let's create a very simple UI using HTML. It will contain a text area to get the input JSON, a submit button to format the input JSON, and another text area to display the output.</p>

<p>Let's modify the existing <code>~/Documents/webassembly/assets/index.html</code> in the <code>assets</code> folder to include the UI.</p>

<pre><code class="language-html line-numbers">&lt;html&gt;  
    &lt;head&gt;
        &lt;meta charset="utf-8"/&gt;
        &lt;script src="wasm_exec.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            const go = new Go();
            WebAssembly.instantiateStreaming(fetch("json.wasm"), go.importObject).then((result) =&gt; {
                go.run(result.instance);
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
         &lt;textarea id="jsoninput" name="jsoninput" cols="80" rows="20"&gt;&lt;/textarea&gt;
         &lt;input id="button" type="submit" name="button" value="pretty json" onclick="json(jsoninput.value)"/&gt;
         &lt;textarea id="jsonoutput" name="jsonoutput" cols="80" rows="20"&gt;&lt;/textarea&gt;
    &lt;/body&gt;
    &lt;script&gt;
        var json = function(input) {
            jsonoutput.value = formatJSON(input)
        }
     &lt;/script&gt;
&lt;/html&gt;  
</code></pre>

<p>In line no. 13 of the above HTML, we create a text area with id <code>jsoninput</code>. This will be our text area where we input the JSON to be formatted.</p>

<p>Next, we create a submit button and when the button is clicked, the <code>json</code> JavaScript function in line no. 18 will be called. This function takes the input JSON as a parameter, calls the <code>formatJSON</code> wasm function which we created in the <a href="https://golangbot.com/webassembly-using-go/">previous tutorial</a> and sets the output to the <code>jsonoutput</code> text area defined in line no. 15. </p>

<p>Let's compile and run this program and see if it works.</p>

<pre><code>cd ~/Documents/webassembly/cmd/wasm/  
GOOS=js GOARCH=wasm go build -o  ../../assets/json.wasm  
cd ~/Documents/webassembly/cmd/server/  
go run main.go  
</code></pre>

<p>Go to the browser and type <code>localhost:9090</code>. You can see the UI with two text areas and a button.</p>

<p>Input the following text in the first text area.</p>

<pre><code>{"website":"golangbot.com", "tutorials": {"string":"https://golangbot.com/strings/", "maps":"https://golangbot.com/maps/", "goroutine":"https://golangbot.com/goroutines/", "channels":"https://golangbot.com/channels/"}}
</code></pre>

<p>Now tap on the <code>pretty json</code> button. You can see that the JSON is formatted and printed in the output text area.</p>

<p><img src="https://golangbot.com/content/images/2020/06/tutorial2-1.png" alt="call Go function from JavaScript">
You can see the above output in the browser. We have successfully called the wasm function and formatted the JSON.</p>

<h3 id="accessingthedomfromgousingjavascript">Accessing the DOM from Go using JavaScript</h3>

<p>In the above section, we called the wasm function, got the formatted JSON string output, and set the output text area with the formatted JSON using JavaScript. </p>

<p>There is one more way to achieve the same output. Instead of passing the formatted JSON string to javascript, it is possible to access the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_"blank"">DOM</a> from Go and set the formatted JSON string to the output text area.</p>

<p>Let's see how this is done.</p>

<p>We need to modify the <code>jsonWrapper</code> function in <code>~/Documents/webassembly/cmd/wasm/main.go</code> to achieve this.</p>

<pre><code class="language-go line-numbers">func jsonWrapper() js.Func {  
    jsonfunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        if len(args) != 1 {
            return "Invalid no of arguments passed"
        }
        jsDoc := js.Global().Get("document")
        if !jsDoc.Truthy() {
            return "Unable to get document object"
        }
        jsonOuputTextArea := jsDoc.Call("getElementById", "jsonoutput")
        if !jsonOuputTextArea.Truthy() {
            return "Unable to get output text area"
        }
        inputJSON := args[0].String()
        fmt.Printf("input %s\n", inputJSON)
        pretty, err := prettyJson(inputJSON)
        if err != nil {
            errStr := fmt.Sprintf("unable to parse JSON. Error %s occurred\n", err)
            return errStr
        }
        jsonOuputTextArea.Set("value", pretty)
        return nil
    })

    return jsonfunc
}
</code></pre>

<p>In line no. 6, we try to get the <code>document</code> property of JavaScript from the <code>global</code> scope. This property is needed to access the output JSON text area. The <a href="https://www.godoc.org/syscall/js#Value.Truthy" target="_"blank"">Truthy</a> function in line no. 7 is JavaScript's way of testing for <code>nil</code>. If truthy returns false, it means the property doesn't exist. Hence the appropriate error string is returned to JavaScript. We do not explicitly return a Go error type. The reason for this and how to handle errors is covered in the next section.</p>

<p>In line no. 10, we use the <a href="https://www.godoc.org/syscall/js#Value.Call" target="_"blank"">call</a> method to call the <code>getElementById</code> function on the <code>jsDoc</code> JavaScript object and pass it the <code>jsonoutput</code> argument. In JavaScript, this line of code corresponds to,</p>

<pre><code>jsDoc.getElementById("jsonoutput")  
</code></pre>

<p>If you recollect, <code>jsonoutput</code> is the <code>id</code> of the output text area in <code>index.html</code>. </p>

<p>This will return the reference to the <code>jsonoutput</code> text area. As we did earlier, we check for <code>truthy</code>.</p>

<p>Now we have access to the <code>jsonoutput</code> text area. In line no. 21, we use the <a href="https://www.godoc.org/syscall/js#Value.Set" target="_"blank"">set</a> method to set the <code>value</code> property of the <code>jsonoutput</code> text area to the formatted JSON string. This will display the formatted JSON in the output text area.</p>

<p>The changes to the Go side of the program is done. </p>

<p>A minor change is needed in the <code>~/Documents/webassembly/assets/index.html</code>. Since the JSON is set from Go directly by manipulating the browser's DOM rather than JavaScript, we can remove the following piece of code.</p>

<p>Change line no. 19 from</p>

<pre><code class="language-html line-numbers">jsonoutput.value = formatJSON(input)  
</code></pre>

<p>to  </p>

<pre><code class="language-html line-numbers">var result = formatJSON(input)  
console.log("Value returned from Go", result)  
</code></pre>

<p>We have removed the code that sets <code>jsonoutput</code> value from JavaScript since this is done from the Go side. We just log the result to the console. If there is an error in the JSON input, the error string that was returned from  <code>jsonfunc</code> will be logged to the console. <br>
<em>Do note that the output text area will not be cleared if there is an error. It will still keep showing its existing content. This will be fixed in the next section.</em></p>

<p>Try running the program again using the following commands and then opening  <code>localhost:9090</code> in the browser.  </p>

<pre><code>cd ~/Documents/webassembly/cmd/wasm/  
GOOS=js GOARCH=wasm go build -o  ../../assets/json.wasm  
cd ~/Documents/webassembly/cmd/server/  
go run main.go  
</code></pre>

<p>The output will be the same. If a Valid JSON is passed, it will be formatted and printed. This is now done from the Go code by manipulating the DOM rather than from the JavaScript. If you pass an invalid JSON, the corresponding error will be logged to the console. </p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="errorhandling">Error Handling</h3>

<p>In the previous section, we just returned a string from the <code>jsonfunc</code> function when an error occurred during the JSON formatting.</p>

<p>The idiomatic way of <a href="https://golangbot.com/error-handling/">handling errors</a> in Go is to return the error. Let's modify the <code>jsonWrapper</code> function in <code>~/Documents/webassembly/cmd/wasm/main.go</code> to return an error and see what happens.</p>

<pre><code class="language-go line-numbers">func jsonWrapper() js.Func {  
    jsonfunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        if len(args) != 1  {
            return errors.New("Invalid no of arguments passed")
        }
        jsDoc := js.Global().Get("document")
        if !jsDoc.Truthy() {
            return errors.New("Unable to get document object")
        }
        jsonOuputTextArea := jsDoc.Call("getElementById", "jsonoutput")
        if !jsonOuputTextArea.Truthy() {
            return errors.New("Unable to get output text area")
        }
        inputJSON := args[0].String()
        fmt.Printf("input %s\n", inputJSON)
        pretty, err := prettyJson(inputJSON)
        if err != nil {
            errStr := fmt.Sprintf("unable to parse JSON. Error %s occurred\n", err)
            return errors.New(errStr)
        }
        jsonOuputTextArea.Set("value", pretty)
        return nil
    })
    return jsonfunc
}
</code></pre>

<p>Line no. 4 is changed to return an <code>error</code> instead of a <code>string</code>. Similar changes are done in other places where error needs to be returned.</p>

<p>Compile and run the code and try inputting an incorrect JSON and see what happens. I have provided the invalid JSON string <code>dfs333{"website</code> as input.</p>

<p><img src="https://golangbot.com/content/images/2020/06/tutorial2-changed.png" alt="panic: ValueOf: invalid value wasm_exec.js"></p>

<p>The program has crashed with the following stack trace.  </p>

<pre><code>input dfs333{"website wasm_exec.js:47:14  
panic: ValueOf: invalid value wasm_exec.js:47:14  
&lt;empty string&gt; wasm_exec.js:47:14  
goroutine 6 [running]: wasm_exec.js:47:14  
syscall/js.ValueOf(0x1db00, 0x40e390, 0x6, 0x7ff8000100000017) wasm_exec.js:47:14  
    /usr/local/go/src/syscall/js/js.go:219 +0x13f wasm_exec.js:47:14
syscall/js.Value.Set(0x7ff8000100000012, 0x41a0d0, 0x3b31e, 0x6, 0x1db00, 0x40e390) wasm_exec.js:47:14  
    /usr/local/go/src/syscall/js/js.go:314 +0x7 wasm_exec.js:47:14
syscall/js.handleEvent() wasm_exec.js:47:14  
    /usr/local/go/src/syscall/js/func.go:91 +0x25 wasm_exec.js:47:14
exit code: 2 wasm_exec.js:138:14  
Value returned from Go undefined  
</code></pre>

<p>As we already discussed in the <a href="https://golangbot.com/webassembly-using-go/">last tutorial</a>, any value returned by <code>jsonfunc</code> will automatically be mapped to the corresponding JavaScript value using the <a href="https://www.godoc.org/syscall/js#ValueOf" target="_"blank"">ValueOf</a> function. If you take a quick look at the <a href="https://www.godoc.org/syscall/js#ValueOf" target="_"blank"">documentation</a> of this function, you can see that there is no mapping for Go's <code>error</code> type to a corresponding JavaScript type. This is the reason the program is crashing with error <code>panic: ValueOf: invalid value</code> when an <code>error</code> type is returned from Go. There is no way to pass errors from Go to Javascript currently. This feature could be added in the future, but currently, it's not available. We have to look at other options when returning errors.</p>

<p>One way to do this is to establish a contract between Go and JavaScript. For example, we can return a <a href="https://golangbot.com/maps">map</a> from Go to JavaScript. If the map contains an <code>error</code> key, it can be considered as an error by JavaScript and handled appropriately.</p>

<p>Let's modify the <code>jsonWrapper</code> function to do this.</p>

<pre><code class="language-go line-numbers">func jsonWrapper() js.Func {  
    jsonfunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        if len(args) != 1 {
            result := map[string]interface{}{
                "error": "Invalid no of arguments passed",
            }
            return result
        }
        jsDoc := js.Global().Get("document")
        if !jsDoc.Truthy() {
            result := map[string]interface{}{
                "error": "Unable to get document object",
            }
            return result
        }
        jsonOuputTextArea := jsDoc.Call("getElementById", "jsonoutput")
        if !jsonOuputTextArea.Truthy() {
            result := map[string]interface{}{
                "error": "Unable to get output text area",
            }
            return result
        }
        inputJSON := args[0].String()
        fmt.Printf("input %s\n", inputJSON)
        pretty, err := prettyJson(inputJSON)
        if err != nil {
            errStr := fmt.Sprintf("unable to parse JSON. Error %s occurred\n", err)
            result := map[string]interface{}{
                "error": errStr,
            }
            return result
        }
        jsonOuputTextArea.Set("value", pretty)
        return nil
    })
    return jsonfunc
}
</code></pre>

<p>In the above snippet, in line no. 4, a map named <code>result</code> with an <code>error</code> key is created and returned with the corresponding error. Similar changes are done in other places. The JavaScript side can now check for the existence of this key. If this key is present, it means an error has occurred and it can be handled appropriately.</p>

<p>The modified <code>index.html</code> file is provided below. Changes are done only to the JavaScript section starting at line no. 17.</p>

<pre><code class="language-html line-numbers">...
    &lt;script&gt;
         var json = function(input) {
                var result = formatJSON(input)
                if (( result != null) &amp;&amp; ('error' in result)) {
                    console.log("Go return value", result)
                    jsonoutput.value = ""
                    alert(result.error)
                }
        }
    &lt;/script&gt;
&lt;/html&gt;  
</code></pre>

<p>The return value from Go is first validated for <code>null</code> and then it is checked to find whether the <code>error</code> key is present. If the error key is present, it means some error has occurred when processing the JSON. The output text area is first cleared and then a popup alert is shown to the user with the error message.</p>

<p>Compile and run the program again. Try passing an invalid JSON. You can see an alert with the error message. The output text area is also cleared.</p>

<p><img src="https://golangbot.com/content/images/2020/06/tutorial2-3.png" alt="Go WebAssembly error handling"></p>

<p>This brings us to the end of this tutorial. </p>

<p>The source code is available at <a href="https://github.com/golangbot/webassembly/tree/tutorial2" target="_"blank"">https://github.com/golangbot/webassembly/tree/tutorial2</a></p>

<p>Please leave your comments and feedback.</p>

<p>If you would like to advertise on this website, hire me, or if you have any other development requirements please email to <em>naveen[at]golangbot[dot]com</em>.</p>]]></content:encoded></item><item><title><![CDATA[WebAssembly: Introduction to WebAssembly using Go]]></title><description><![CDATA[A tutorial about WebAssembly and how to cross compile and run Go programs in the browser using WebAssembly. ]]></description><link>https://golangbot.com/webassembly-using-go/</link><guid isPermaLink="false">774ed15b-6b73-4ca4-911b-29c0e6c9637f</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sun, 21 Jun 2020 14:51:45 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 1 of our WebAssembly tutorial series. </p>

<h3 id="seriesindex">Series Index</h3>

<p><a href="https://golangbot.com/webassembly-using-go">Introduction to WebAssembly Using Go</a><br>
<a href="https://golangbot.com/go-webassembly-dom-access/">DOM Access and Error Handling</a></p>

<h3 id="whatiswebassembly">What is WebAssembly?</h3>

<p>JavaScript has been the only programming language that the browser understands. JavaScript has stood the test of time and it has been able to deliver the performance needed by most web applications. But when it comes to 3D games, VR, AR, and image editing apps, JavaScript is not quite up to the mark since it is interpreted. Although JavaScript engines such as Gecko and V8 have <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_"blank"">Just in Time compilation</a>  capabilities, JavaScript is not able to provide the high performance required by modern web applications. </p>

<p>WebAssembly(also known as wasm) is meant to solve this problem. WebAssembly is a virtual assembly language for the browser. When we say virtual, it means that it cannot be run natively on the underlying hardware. Since the browser can be running on any architecture, it is not possible for the browser to run WebAssembly directly on the underlying hardware. But this highly optimized virtual assembly format can be processed much quicker than vanilla JavaScript by modern browsers since it is compiled and is more close to the hardware architecture than JavaScript. The following figure shows where WebAssembly stands in the stack when compared to Javascript. It is closer to the Hardware than JavaScript.</p>

<p><img src="https://golangbot.com/content/images/2020/06/block-diagram.png" alt="WebAssembly is closer to the hardware">
 The existing JavaScript engines have support to run WebAssembly's Virtual Assembly Code.</p>

<p><strong>WebAssembly is not meant to replace JavaScript. It is meant to operate hand in hand with JavaScript to take care of performance critical components of a web application.</strong> It is possible to make calls from JavaScript to WebAssembly and vice versa.</p>

<p><strong>WebAssembly is not generally coded by hand, but rather, it is cross compiled from other high level programming languages. For example, it is possible to cross compile Go, C, C++, and Rust code to WebAssembly. Thus the module which has already been coded in some other programming language can be cross compiled to WebAssembly and used in the browser directly.</strong></p>

<h3 id="whatarewedeveloping">What are we developing?</h3>

<p>In this tutorial, we will cross compile a Go application to WebAssembly and run it on the browser. </p>

<p>We will create a simple application that is used to format JSON ðŸ™‚. If a JSON without any formatting is passed as input, it will be formatted and printed.</p>

<p>For example, if the input JSON is</p>

<pre><code>{"website":"golangbot.com", "tutorials": {"string":"https://golangbot.com/strings/", "maps":"https://golangbot.com/maps/", "goroutine":"https://golangbot.com/goroutines/", "channels":"https://golangbot.com/channels/"}}
</code></pre>

<p>It will be formatted as shown below and displayed in the browser. </p>

<pre><code>{
  "tutorials": {
    "channels": "https://golangbot.com/channels/",
    "goroutine": "https://golangbot.com/goroutines/",
    "maps": "https://golangbot.com/maps/",
    "string": "https://golangbot.com/strings/"
  },
  "website": "golangbot.com"
}
</code></pre>

<p>We will also be creating a UI for this application and manipulating the browser's DOM from Go using Javascript, but that's in the <a href="https://golangbot.com/go-webassembly-dom-access/">next tutorial</a>.</p>

<p>This tutorial has been tested using Go Versions >= 1.13. </p>

<h3 id="helloworldwebassemblyprogramcrosscompiledfromgo">Hello World WebAssembly Program Cross Compiled from Go</h3>

<p>Let's start by writing a simple hello world program in Go, cross compile it to WebAssembly, and run it on the browser. We will further modify this application as the tutorial progress and convert it to our JSON formatting application.</p>

<p>Let's create the following directory structure inside the <code>Documents</code> directory. </p>

<pre><code>Documents/  
â””â”€â”€ webassembly
    â”œâ”€â”€ assets
    â””â”€â”€ cmd
        â”œâ”€â”€ server
        â””â”€â”€ wasm
</code></pre>

<p>The use of each of these folders will be clear as the tutorial progresses.</p>

<p>Create a file named <code>main.go</code> with the following contents inside <code>~/Documents/webassembly/cmd/wasm</code>.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    fmt.Println("Go Web Assembly")
}
</code></pre>

<p>Let's cross compile the above Go program into WebAssembly. The following command will cross compile this Go program and place the output binary inside the <code>assets</code> folder.</p>

<pre><code>cd ~/Documents/webassembly/cmd/wasm/  
GOOS=js GOARCH=wasm go build -o  ../../assets/json.wasm  
</code></pre>

<p>The above command uses <code>js</code> as <code>GOOS</code> and <code>wasm</code> which is the short form for WebAssembly as the architecture. Running the above command will create the WebAssembly module <code>json.wasm</code> in the <code>assets</code> directory. Congrats, we have successfully cross compiled our first Go program to WebAssembly ðŸ˜€.</p>

<p>One important fact is that it is possible to cross compile only the <code>main</code> package to WebAssembly. Hence we have written our code in the main <a href="https://golangbot.com/go-packages/">package</a>.</p>

<p>If you try to run this compiled binary in the terminal,</p>

<pre><code>$]~/Documents/webassembly/assets/json.wasm 

-bash: json.wasm: cannot execute binary file: Exec format error
</code></pre>

<p>You will get the error <code>cannot execute binary file: Exec format error</code>. This is because this binary is a <code>wasm</code> binary and is supposed to be run inside a browser sandbox. The Linux/Mac OSes don't understand the format of this binary. Hence we get this error. </p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="javascriptglue">Javascript Glue</h3>

<p>As we already discussed, WebAssembly is supposed to exist hand in hand with JavaScript. Hence some JavaScript glue code is needed to import the WebAssembly Module we just created and run it in the browser. This code is already available in the Go installation. Let's go ahead and copy it to our assets directory.</p>

<pre><code>cp "$(go env GOROOT)/misc/wasm/wasm_exec.js" ~/Documents/webassembly/assets/  
</code></pre>

<p>The above command copies the <code>wasm_exec.js</code> that contains the glue code to run WebAssembly into the <code>assets</code> directory. </p>

<p>As you would have guessed by now, <code>assets</code> folder will contain all the HTML, JavaScript, and wasm code which will be served using a web server later. </p>

<h3 id="indexhtml">Index.html</h3>

<p>Now we have the wasm binary ready and also have the glue code. The next step is to create the <code>index.html</code> file and import our wasm binary.</p>

<p>Let's create a file named <code>index.html</code> in the <code>assets</code> directory with the following contents. This file contains boilerplate code to run the WebAssembly module and it can be found in the <a href="https://github.com/golang/go/wiki/WebAssembly#getting-started" target="_"blank"">WebAssembly Wiki</a>. </p>

<pre><code class="language-html line-numbers">&lt;html&gt;  
    &lt;head&gt;
        &lt;meta charset="utf-8"/&gt;
        &lt;script src="wasm_exec.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            const go = new Go();
            WebAssembly.instantiateStreaming(fetch("json.wasm"), go.importObject).then((result) =&gt; {
                go.run(result.instance);
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>The current directory structure after creating <code>index.html</code> is provided below.</p>

<pre><code>Documents/  
â””â”€â”€ webassembly
    â”œâ”€â”€ assets
    â”‚Â Â  â”œâ”€â”€ index.html
    â”‚Â Â  â”œâ”€â”€ json.wasm
    â”‚Â Â  â””â”€â”€ wasm_exec.js
    â””â”€â”€ cmd
        â”œâ”€â”€ server
        â””â”€â”€ wasm
            â””â”€â”€ main.go
</code></pre>

<p>Although the contents of <code>index.html</code> is standard boilerplate, a little understanding doesn't hurt. Let's try to understand the code in <code>index.html</code> a little.  The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming" target="_"blank"">instantiateStreaming</a> function is used to initialize our <code>json.wasm</code> WebAssembly module. This function returns a WebAssembly <code>instance</code>which contains the list of WebAssembly functions that can be called from JavaScript. This is required to call our wasm functions from JavaScript. The use of this will be more clear as the tutorial progresses.  </p>

<h3 id="webserver">WebServer</h3>

<p>Now we have our JavaScript glue, index.html, and our wasm binary ready. The only missing piece is that we need to create a webserver to serve the contents of the assets folder.  Let's do that now. </p>

<p>Create a file named <code>main.go</code> inside the <code>server</code> directory. The directory structure after creating <code>main.go</code> is provided below.  </p>

<pre><code>Documents/  
â””â”€â”€ webassembly
    â”œâ”€â”€ assets
    â”‚   â”œâ”€â”€ index.html
    â”‚   â”œâ”€â”€ json.wasm
    â”‚   â””â”€â”€ wasm_exec.js
    â””â”€â”€ cmd
        â”œâ”€â”€ server
        |   â””â”€â”€ main.go
        â””â”€â”€ wasm
            â””â”€â”€ main.go
</code></pre>

<p>Add the following code to <code>~/Documents/webassembly/cmd/server/main.go</code>.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "net/http"
)

func main() {  
    err := http.ListenAndServe(":9090", http.FileServer(http.Dir("../../assets")))
    if err != nil {
        fmt.Println("Failed to start server", err)
        return
    }
}
</code></pre>

<p>The above program creates a file server listening at port <code>9090</code> with the root at our <code>assets</code> folder. Just what we wanted. Let's run the server and see our first WebAssembly program running.</p>

<pre><code>cd ~/Documents/webassembly/cmd/server/  
go run main.go  
</code></pre>

<p>Now the server is listening at port <code>9090</code>. Go to your favorite web browser and type <code>http://localhost:9090/</code>. You can see that the page is empty. Don't worry about it, we will create the UI in the upcoming sections. </p>

<p>Our interest right now is to see the JavaScript console. Right click and select <code>inspect element</code> in the browser. <br>
<img src="https://golangbot.com/content/images/2020/06/tutorial1-2.png" alt="inspect WebAssembly"></p>

<p>This will open the developer console. Tap on the tab named "console".</p>

<p><img src="https://golangbot.com/content/images/2020/06/tutorial1-1.png" alt="developer console"></p>

<p>You can see the text <code>Go Web Assembly</code> printed in the console. Awesome, we have successfully run our first Web Assembly program written using Go. Our web assembly module cross compiled from Go has been delivered by our server to the browser and it has been executed successfully by the browser's Javascript engine. </p>

<p>Let's take this tutorial to the next level and write the code for our JSON formatter.</p>

<h3 id="codingthejsonformatter">Coding the JSON formatter</h3>

<p>Our JSON formatter will take an unformatted JSON as input, format it, and return the formatted JSON <a href="https://golangbot.com/strings/">string</a> as output. We will be using the <a href="https://golang.org/pkg/encoding/json/#MarshalIndent" target="_"blank"">MarshalIndent</a> function to accomplish this. </p>

<p>Add the following function to <code>~/Documents/webassembly/cmd/wasm/main.go</code></p>

<pre><code class="language- language-go line-numbers">func prettyJson(input string) (string, error) {  
    var raw interface{}
    if err := json.Unmarshal([]byte(input), &amp;raw); err != nil {
        return "", err
    }
    pretty, err := json.MarshalIndent(raw, "", "  ")
    if err != nil {
        return "", err
    }
    return string(pretty), nil
}
</code></pre>

<p>The <code>MarshalIndent</code> function takes 3 parameters as input. The first one is the raw unformatted JSON, the second one is the prefix to add to each new line of the JSON. In this case, we don't add a prefix. The third parameter is the string to be appended for each indent of our JSON. In our case, we give pass two spaces. Simply put, for each new indent of the JSON, two spaces will be added and hence the JSON will be formatted. </p>

<p>If  the string <code>{"website":"golangbot.com", "tutorials": {"string":"https://golangbot.com/strings/"}}</code> is passed as input to the above <a href="https://golangbot.com/functions">function</a>, it will return the following formatted JSON string as output.</p>

<pre><code>{
  "tutorials": {
    "string": "https://golangbot.com/strings/"
  },
  "website": "golangbot.com"
}
</code></pre>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="exposingafunctionfromgotojavascript">Exposing a function from Go to Javascript</h3>

<p>Now we have the function ready but we are yet to expose this function to Javascript so that it can be called from the front end. </p>

<p>Go provides the <a href="https://www.godoc.org/syscall/js" target="_"blank"">syscall/js</a> package which helps in exposing functions from Go to Javascript. </p>

<p><strong>The first step in exposing a function from <code>Go</code> to <code>JavaScript</code> is to create a <a href="https://www.godoc.org/syscall/js#Func" target="_"blank"">Func</a> type. Func is a wrapped Go function that can be called by JavaScript. The <a href="https://www.godoc.org/syscall/js#FuncOf" target="_"blank"">FuncOf</a> function can be used to create a <code>Func</code> type.</strong></p>

<p>Add the following function to <code>~/Documents/webassembly/cmd/wasm/main.go</code>  </p>

<pre><code class="language-go line-numbers">func jsonWrapper() js.Func {  
        jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
                if len(args) != 1 {
                        return "Invalid no of arguments passed"
                }
                inputJSON := args[0].String()
                fmt.Printf("input %s\n", inputJSON)
                pretty, err := prettyJson(inputJSON)
                if err != nil {
                        fmt.Printf("unable to convert to json %s\n", err)
                        return err.Error()
                }
                return pretty
        })
        return jsonFunc
}
</code></pre>

<p>The <code>FuncOf</code> function takes a <a href="https://golangbot.com/first-class-functions/">first class function function</a> with two parameters and a <code>interface{}</code> return type as input. The function which is passed to <code>FuncOf</code> will be called synchronously from Javascript. The first parameter of this function is Javascript's <code>this</code> keyword. <code>this</code> refers to JavaScript's <code>global</code> object.  The second parameter is a <a href="https://golangbot.com/arrays-and-slices/">slice</a> of <code>[]js.Value</code> which represents the arguments that will be passed to the Javascript function call. In our case, it will be the unformatted JSON input string. Don't worry if this doesn't make sense. Once the program is complete, you will be able to understand better :). </p>

<p>We first check whether only one argument has been passed from Javascript in line no. 3. This check is needed because we expect only one JSON string argument. If not we return a string message stating <code>Invalid no of arguments passed</code>. <em>We do not explicitly return any error type from Go to Javascript. Error handling will be taken care of in the <a href="https://golangbot.com/go-webassembly-dom-access/">next tutorial</a>.</em></p>

<p>We get the JSON input using <code>args[0].String()</code>. This represents the first parameter passed from JavaScript. This will be more clear as the tutorial progresses. After the input JSON is obtained, we call the <code>prettyJson</code> function in line no. 8, and return the output. </p>

<p><strong>When returning a value from Go to Javascript, the <a href="https://www.godoc.org/syscall/js#ValueOf" target="_"blank"">ValueOf</a> function will be used automatically by the compiler to convert the Go value to a JavaScript value.</strong> In this case, we are returning a <code>string</code> from Go, hence it will be converted to the corresponding JavaScript's string type using <code>js.ValueOf()</code> by the compiler.</p>

<p>We assign the <code>FuncOf</code>'s return value to <code>jsonFunc</code>. Now <code>jsonFunc</code> contains the function which will be called from Javascript. We return <code>jsonFunc</code> in line no. 15.</p>

<p>Now we have the function ready which can be called from Javascript. We are still one step away.</p>

<p>We need to expose the function we just created so that it can be called from Javascript. The way we will expose the Go function to Javascript is by setting the <code>formatJSON</code> string property of JavaScript's global object to the <code>js.Func</code> returned by <code>jsonWrapper()</code>.</p>

<p>The line of code that does this is,</p>

<pre><code>js.Global().Set("formatJSON", jsonWrapper())  
</code></pre>

<p>Add this to the end of the <code>main()</code> function. In the above code, we have set the  <code>formatJSON</code> property of Javascript's Global object to the return value of <code>jsonWrapper()</code> function. Now the <code>jsonFunc</code> which format's the JSON can be called from JavaScript using the function name <code>formatJSON</code>.</p>

<p>The complete program is provided below.  </p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "encoding/json"
    "syscall/js"
)

func prettyJson(input string) (string, error) {  
        var raw interface{}
        if err := json.Unmarshal([]byte(input), &amp;raw); err != nil {
                return "", err
        }
        pretty, err := json.MarshalIndent(raw, "", "  ")
        if err != nil {
                return "", err
        }
        return string(pretty), nil
}

func jsonWrapper() js.Func {  
        jsonFunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
                if len(args) != 1 {
                        return "Invalid no of arguments passed"
                }
                inputJSON := args[0].String()
                fmt.Printf("input %s\n", inputJSON)
                pretty, err := prettyJson(inputJSON)
                if err != nil {
                        fmt.Printf("unable to convert to json %s\n", err)
                        return err.Error()
                }
                return pretty
        })
        return jsonFunc
}

func main() {  
    fmt.Println("Go Web Assembly")
    js.Global().Set("formatJSON", jsonWrapper())
}
</code></pre>

<p>Let's compile and test our program.</p>

<pre><code>cd ~/Documents/webassembly/cmd/wasm/  
GOOS=js GOARCH=wasm go build -o  ../../assets/json.wasm  
cd ~/Documents/webassembly/cmd/server/  
go run main.go  
</code></pre>

<p>The above commands will compile the wasm binary and start our webserver. </p>

<h3 id="callingthegofunctionfromjavascript">Calling the Go function from JavaScript</h3>

<p>We have exposed the Go function to JavaScript successfully. Let's check whether it works. </p>

<p>Go the browser and open the same URL <code>http://localhost:9090/</code> again and open the Javascript console.</p>

<p>Type the following command in the Javascript console.</p>

<pre><code>formatJSON('{"website":"golangbot.com", "tutorials": {"string":"https://golangbot.com/strings/"}}')  
</code></pre>

<p>The above command calls the <code>formatJSON</code> JavaScript function which we exposed from Go and passes it as JSON string as an argument. Hit enter. Did it work? <br>
Sorry :) bummer. You would have got the error <code>Error: Go program has already exited</code> <br>
<img src="https://golangbot.com/content/images/2020/06/tutorial1-3.png" alt="Error: Go program has already exited">
The reason as the error mentions is our Go program has already exited when it was called from Javascript. How do we fix this ðŸ¤”? Well, it's pretty simple. We must ensure that the Go program is running when JavaScript calls it. The easy way to do this in Go is to keep waiting on a channel.</p>

<pre><code class="language-go line-numbers">func main() {  
        fmt.Println("Go Web Assembly")
        js.Global().Set("formatJSON", jsonWrapper())
        &lt;-make(chan bool)
}
</code></pre>

<p>In the above snippet, we are waiting on a channel. Please add the last line of the above snippet to <code>~/Documents/webassembly/cmd/wasm/main.go</code> and compile ane rerun the program. Try running the following command in the browser again.</p>

<pre><code>formatJSON('{"website":"golangbot.com", "tutorials": {"string":"https://golangbot.com/strings/"}}')  
</code></pre>

<p>Now the JSON will be formatted and printed.</p>

<p><img src="https://golangbot.com/content/images/2020/06/Screenshot-2020-06-19-at-12.50.32-AM.png" alt="WebAssembly JSON Formatter using Go"></p>

<p>If no parameters are passed,</p>

<pre><code>formatJSON()  
</code></pre>

<p>we will get the message, </p>

<pre><code>"Invalid no of arguments passed"
</code></pre>

<p>in the output.</p>

<p>Great. We have successfully called a function written using Go from JavaScript. </p>

<p>The source code for this tutorial is available at <a href="https://github.com/golangbot/webassembly/tree/tutorial1/" target="_"blank"">https://github.com/golangbot/webassembly/tree/tutorial1/</a></p>

<p>In the <a href="https://golangbot.com/go-webassembly-dom-access/">next tutorial</a>, we will create a UI for our application, handle errors, and also modify the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_"blank"">DOM</a> from Go.</p>

<p>If you would like to advertise on this website, hire me, or if you have any other development requirements please email to <em>naveen[at]golangbot[dot]com</em>.</p>

<p>Thanks for reading. Please leave your comments and feedback.Â </p>

<p><strong>Next tutorial - <a href="https://golangbot.com/go-webassembly-dom-access/">DOM Access and Error Handling</a></strong></p>]]></content:encoded></item><item><title><![CDATA[Debugging Go Applications using Delve]]></title><description><![CDATA[This tutorial gives an overview of how to debug Go applications using Delve. It covers the commonly used commands such as breakpoint, continue, next and step.]]></description><link>https://golangbot.com/debugging-go-delve/</link><guid isPermaLink="false">a130ca6c-ef46-42a2-add2-99aa6d3d2d85</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Mon, 27 Apr 2020 11:59:00 GMT</pubDate><content:encoded><![CDATA[<h3 id="needforadebugger">Need for a debugger</h3>

<p>The simplest form of debugging in any programming language is by using print statements/logs and writing to standard out. This definitely works but becomes extremely difficult when the size of our application grows and the logic becomes more complex. Adding print statements to every code path of the application is not easy. This is where debuggers come in handy. Debuggers help us to trace the execution path of the program using <a href="https://en.wikipedia.org/wiki/Breakpoint" target="_"blank"">breakpoints</a> and a host of other features. <a href="https://github.com/go-delve/" target="_"blank"">Delve</a> is one such debugger for Go. In this tutorial, we will learn how to Debug Go applications using Delve.</p>

<h3 id="installingdelve">Installing Delve</h3>

<p>Please ensure that you are inside a directory which doesn't contain a go.mod file. I prefer my <code>Documents</code> directory.</p>

<pre><code>cd ~/Documents/  
</code></pre>

<p>Next, let's set the <code>GOBIN</code> environment variable. This environment variable specifies the location where the <code>Delve</code> binary will be installed. Please skip this step if you have the <code>GOBIN</code> already set. You can check whether <code>GOBIN</code> is set by running the command below.</p>

<pre><code>go env | grep GOBIN  
</code></pre>

<p>If the above command prints, <code>GOBIN=""</code>, it means that <code>GOBIN</code> is not set. Please run <code>export GOBIN=~/go/bin/</code> command to set GOBIN.</p>

<p>Let's add <code>GOBIN</code> to the <code>PATH</code> by running <code>export PATH=$PATH:~/go/bin</code></p>

<p>In the case of <strong>macOS</strong>, the Xcode command line developer tools are needed to run Delve. Please run <code>xcode-select --install</code> to install the command line tools. Linux users can skip this step.</p>

<p>Now we are set to install <code>Delve</code>. Please run  </p>

<pre><code>go get github.com/go-delve/delve/cmd/dlv  
</code></pre>

<p>
to install delve. After running this command, please test your installation by running <code>dlv version</code>. It will print the version of Delve on successful installation.</p>

<pre><code>Delve Debugger  
Version: 1.4.0  
Build: $Id: 67422e6f7148fa1efa0eac1423ab5594b223d93b  
</code></pre>

<h3 id="startingdelve">Starting Delve</h3>

<p>Let's write a simple program and then start debugging it using Delve.</p>

<p>Let's create a directory for our sample program using the following command.</p>

<pre><code>mkdir ~/Documents/debugsample  
</code></pre>

<p>Create a file <code>main.go</code> inside the <code>debugsample</code> directory we just created with the following contents.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    arr := []int{101, 95, 10, 188, 100}
    max := arr[0]
    for _, v := range arr {
        if v &gt; max {
            max = v
        }
    }
    fmt.Printf("Max element is %d\n", max)
}
</code></pre>

<p>The program above will print the biggest element of the <a href="https://golangbot.com/arrays-and-slices/#slices">slice</a> <code>arr</code>. <a href="https://golangbot.com/hello-world-gomod/#runningagoprogram">Running</a> the above program will output,  </p>

<pre><code>Max element is 188  
</code></pre>

<p>We are now ready to debug the program. Let's move to the debugsample directory <code>cd ~/Documents/debugsample</code>. After that, type the following command to start Delve.</p>

<pre><code>dlv debug  
</code></pre>

<p>The above command will start debugging the <code>main</code> <a href="https://golangbot.com/go-packages/">package</a> in the current directory. After typing the above command, you can see that the terminal has changed to <code>(dlv)</code> prompt. If you can see this change, it means that the debugger has started successfully and waiting for our commands :).</p>

<p>Let's fire our first command.</p>

<p>In the <code>dlv</code> prompt, type <code>continue</code>.</p>

<pre><code>(dlv) continue
</code></pre>

<p><strong>The <code>continue</code> command will run the program until there is a breakpoint or till completion of the program. Since we do not have any breakpoints defined, the program will run till completion.</strong></p>

<pre><code>Max element is 188  
Process 1733 has exited with status 0  
</code></pre>

<p>If you see the above output, the debugger has run and the program is completed :). But this was not of any use to us. Let's go ahead and add a couple of breakpoints and watch the debugger do its magic.</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="creatingbreakpoints">Creating Breakpoints</h3>

<p><strong>Breakpoints pause the execution of the program at a specified line.</strong> When the execution is paused, we can send commands to the debugger to print the value of the variables, look at the stack trace of the program, and so on. </p>

<p>The syntax for creating a breakpoint is provided below,</p>

<pre><code>(dlv) break filename:lineno
</code></pre>

<p>The above command will create a breakpoint at line <code>lineno</code> in the file <code>filename</code>.</p>

<p>Let's add a breakpoint to line no. 9 of our <code>main.go</code>. </p>

<pre><code>(dlv) break main.go:9
</code></pre>

<p>When the above command is run, you can see the output, <code>Process 1733 has exited with status 0</code>. <strong>The breakpoint was not added actually</strong>. This is because the program has exited when we ran <code>continue</code> earlier since there were no breakpoints at that time. Let's restart the program and try setting the breakpoint again.</p>

<pre><code>(dlv) restart
Process restarted with PID 2028  
(dlv) break main.go:9
Breakpoint 1 set at 0x10c16e4 for main.main() ./main.go:9  
</code></pre>

<p>The <code>restart</code> command restarts the program and then the <code>break</code> command sets the breakpoint. The above output confirms that the breakpoint with name <code>1</code> is set at line no. 9 in main.go.</p>

<p>Now let's <code>continue</code> our program and check whether the debugger pauses the program at the breakpoint.</p>

<pre><code>(dlv) continue
</code></pre>

<pre><code>&gt; main.main() ./main.go:9 (hits goroutine(1):1 total:1) (PC: 0x10c16e4)
     4:        "fmt"
     5:    )
     6:    
     7:    func main() {
     8:        arr := []int{101, 95, 10, 188, 100}
=&gt;   9:        max := arr[0]
    10:        for _, v := range arr {
    11:            if v &gt; max {
    12:                max = v
    13:            }
    14:        }
</code></pre>

<p>After <code>continue</code> is executed, we can see that the debugger has paused our program at line no 9. Just what we wanted :).</p>

<h3 id="listingbreakpoints">Listing breakpoints</h3>

<pre><code>(dlv) breakpoints
</code></pre>

<p>The above command lists the current breakpoints of the application. </p>

<pre><code>(dlv) breakpoints
Breakpoint runtime-fatal-throw at 0x102de10 for runtime.fatalthrow() /usr/local/Cellar/go/1.13.7/libexec/src/runtime/panic.go:820 (0)  
Breakpoint unrecovered-panic at 0x102de80 for runtime.fatalpanic() /usr/local/Cellar/go/1.13.7/libexec/src/runtime/panic.go:847 (0)  
    print runtime.curg._panic.arg
Breakpoint 1 at 0x10c16e4 for main.main() ./main.go:9 (1)  
</code></pre>

<p>You might be surprised to see that there are two other breakpoints in addition to the one we added. The other two breakpoints are added by delve to ensure that the debugging session does not end abruptly when there is a runtime <em><a href="https://golangbot.com/panic-and-recover/">panic</a></em> that is not handled using <em><a href="https://golangbot.com/panic-and-recover/">recover</a></em>.</p>

<h3 id="printingvariables">Printing variables</h3>

<p>The program's execution has paused at line no. 9. <code>print</code> is the command used to print the value of a variable. Let's use <code>print</code> and print the element at the 0th index of the slice <code>arr</code>.</p>

<pre><code>(dlv) print arr[0]
</code></pre>

<p>Running the above command will print <code>101</code> which is the element at the 0th index of the slice <code>arr</code>.</p>

<p>Do note that if we try to print <code>max</code>, we will get a junk value printed.</p>

<pre><code>(dlv) print max
824634294736  
</code></pre>

<p>This is because the program has paused before line no. 9 is executed and hence printing <code>max</code> prints some random junk value. To print the actual value of max, we should move to the next line of the program. This can be done using the <code>next</code> command.</p>

<h3 id="movetonextlineinthesource">Move to next line in the source</h3>

<pre><code>(dlv) next
</code></pre>

<p>will move the debugger to the next line and it will output,</p>

<pre><code>&gt; main.main() ./main.go:10 (PC: 0x10c16ee)
     5:    )
     6:    
     7:    func main() {
     8:        arr := []int{101, 95, 10, 188, 100}
     9:        max := arr[0]
=&gt;  10:        for _, v := range arr {
    11:            if v &gt; max {
    12:                max = v
    13:            }
    14:        }
    15:        fmt.Printf("Max element is %d\n", max)
</code></pre>

<p>Now if we try <code>(dlv) print max</code> we can see the output <code>101</code>.</p>

<p><strong>next</strong> command can be used to walk through a program line by line. </p>

<p>If you keep typing <code>next</code>, you can see that the debugger walks you line by line in the program. When one iteration of the <code>for</code> loop in line no. 10 is over,  <code>next</code> will walk us through the next iteration and the program will terminate eventually.</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="printingexpressions">Printing expressions</h3>

<p><em>print</em> can also be used to evaluate expressions. For example, if we want to find the value of <code>max + 10</code>, it's possible using print.</p>

<p>Let's add another breakpoint outside the <code>for</code> loop where the computation of <code>max</code> will be completed.</p>

<pre><code>(dlv) break main.go:15
</code></pre>

<p>The above command adds another breakpoint to line no. 15 where the computation of max is finished.</p>

<p>Type <code>continue</code> and the program will stop at this breakpoint.</p>

<p><em>print max+10</em> command will output <em>198</em>.</p>

<h3 id="clearingbreakpoints">Clearing breakpoints</h3>

<p><strong>clear</strong> is the command to clear a single breakpoint and <strong>clearall</strong> is the command to clear all breakpoints in the program.</p>

<p>Let's first list the breakpoints in our application.</p>

<pre><code>(dlv) breakpoints

Breakpoint runtime-fatal-throw at 0x102de10 for runtime.fatalthrow() /usr/local/Cellar/go/1.13.7/libexec/src/runtime/panic.go:820 (0)  
Breakpoint unrecovered-panic at 0x102de80 for runtime.fatalpanic() /usr/local/Cellar/go/1.13.7/libexec/src/runtime/panic.go:847 (0)  
    print runtime.curg._panic.arg
Breakpoint 1 at 0x10c16e4 for main.main() ./main.go:9 (1)  
Breakpoint 2 at 0x10c1785 for main.main() ./main.go:15 (1)  
</code></pre>

<p>We have two breakpoints named <code>1</code> and <code>2</code></p>

<p>If we run <code>clear 1</code>, it will delete the breakpoint <code>1</code>.</p>

<pre><code>(dlv) clear 1
Breakpoint 1 cleared at 0x10c16e4 for main.main() ./main.go:9  
</code></pre>

<p>If we run <code>clearall</code>, it will delete all breakpoints. We have only one breakpoint named <code>2</code> remaining. </p>

<pre><code>(dlv) clearall
Breakpoint 2 cleared at 0x10c1785 for main.main() ./main.go:15  
</code></pre>

<p>From the above output, we can see that the remaining one breakpoint is also cleared. If we executed <code>continue</code> command now, the program will print the <code>max</code> value and terminate.</p>

<pre><code>(dlv) continue
Max element is 188  
Process 3095 has exited with status 0  
</code></pre>

<h3 id="stepintoandoutofafunction">Step into and out of a function</h3>

<p>It is possible to use Delve to step into a <a href="https://golangbot.com/functions/">function</a> or out of a function. Don't worry if it doesn't make sense now :). Let's try to understand this with the help of an example.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func max(arr []int) int {  
    max := arr[0]
    for _, v := range arr {
        if v &gt; max {
            max = v
        }
    }
    return max
}
func main() {  
    arr := []int{101, 95, 10, 188, 100}
    m := max(arr)
    fmt.Printf("Max element is %d\n", m)
}
</code></pre>

<p>I have modified the program we have been using till now and moved the logic which finds the biggest element of the slice to its own function named <code>max</code>.</p>

<p>Quit Delve using <code>(dlv) q</code>, replace <code>main.go</code> with the program above and then start debugging again using the command <code>dlv debug</code>.</p>

<p>Let's add a breakpoint at line. no 18 where the <code>max</code> function is called.</p>

<p><strong>b</strong> is the shorthand for adding a breakpoint. Let's use that.</p>

<pre><code>(dlv) b main.go:18
(dlv) continue
</code></pre>

<p>We have added the breakpoint at line no.18 and continued the execution of the program. Running the above commands will print,</p>

<pre><code>&gt; main.main() ./main.go:18 (hits goroutine(1):1 total:1) (PC: 0x10c17ae)
    13:        }
    14:        return max
    15:    }
    16:    func main() {
    17:        arr := []int{101, 95, 10, 188, 100}
=&gt;  18:        m := max(arr)
    19:        fmt.Printf("Max element is %d\n", m)
    20:    }
</code></pre>

<p>The program execution has paused at line no. 18 as expected. Now we have two options.</p>

<ul>
<li>Continue debugging deeper into the <code>max</code> function</li>
<li>Skip the max function and move to the next line.</li>
</ul>

<p>Depending on our requirement we can do either. Let's learn how to do both.</p>

<p>First, let's skip the max function and move to the next line. To do this, you can just run <code>next</code> and the debugger will automatically move to the next line. By default, Delve doesn't go deeper into function calls.</p>

<pre><code>(dlv) next
&gt; main.main() ./main.go:19 (PC: 0x10c17d3)
    14:        return max
    15:    }
    16:    func main() {
    17:        arr := []int{101, 95, 10, 188, 100}
    18:        m := max(arr)
=&gt;  19:        fmt.Printf("Max element is %d\n", m)
    20:    }
</code></pre>

<p>You can see from the above output that the debugger has moved to the next line. </p>

<p>Type <code>continue</code> and the program will finish executing. </p>

<p>Let's learn how to go deeper into the max function.</p>

<p>Type <code>restart</code> and <code>continue</code> and we can see the program paused again at the already existing breakpoint.</p>

<pre><code>(dlv) restart
Process restarted with PID 5378  
(dlv) continue
&gt; main.main() ./main.go:18 (hits goroutine(1):1 total:1) (PC: 0x10c17ae)
    13:        }
    14:        return max
    15:    }
    16:    func main() {
    17:        arr := []int{101, 95, 10, 188, 100}
=&gt;  18:        m := max(arr)
    19:        fmt.Printf("Max element is %d\n", m)
    20:    }
</code></pre>

<p>Now type <code>step</code> and we can see that the control has moved into the <code>max</code> function now.</p>

<pre><code>(dlv) step
&gt; main.max() ./main.go:7 (PC: 0x10c1650)
     2:    
     3:    import (
     4:        "fmt"
     5:    )
     6:    
=&gt;   7:    func max(arr []int) int {
     8:        max := arr[0]
     9:        for _, v := range arr {
    10:            if v &gt; max {
    11:                max = v
    12:            }
</code></pre>

<p>Type <code>next</code> and the control will move to the first line of the <code>max</code> function.</p>

<pre><code>(dlv) next
&gt; main.max() ./main.go:8 (PC: 0x10c1667)
     3:    import (
     4:        "fmt"
     5:    )
     6:    
     7:    func max(arr []int) int {
=&gt;   8:        max := arr[0]
     9:        for _, v := range arr {
    10:            if v &gt; max {
    11:                max = v
    12:            }
    13:        }
</code></pre>

<p>If you keep typing <code>next</code> you can step through the execution path of the <code>max</code> function.</p>

<p>You might be wondering whether it is possible to return to <code>main</code> without stepping through each line in the <code>max</code> function. Yes, this is possible using the <code>stepout</code> command.</p>

<pre><code>(dlv) stepout
&gt; main.main() ./main.go:18 (PC: 0x10c17c9)
Values returned:  
    ~r1: 188

    13:        }
    14:        return max
    15:    }
    16:    func main() {
    17:        arr := []int{101, 95, 10, 188, 100}
=&gt;  18:        m := max(arr)
    19:        fmt.Printf("Max element is %d\n", m)
    20:    }
</code></pre>

<p>Once you type <code>stepout</code>, the control returns back to main. Now you can continue debugging in <code>main</code> :).</p>

<h3 id="printingstacktrace">Printing stack trace</h3>

<p>A very important functionality needed when debugging is to print the current stack trace of the program. This is useful to find out the current code execution path. <code>stack</code> is the command used to print the current stack trace.</p>

<p>Let's clear all breakpoints add a new breakpoint at line no. 11 and print the current stack trace of the program.</p>

<pre><code>(dlv) restart
(dlv) clearall
(dlv) b main.go:11
(dlv) continue
</code></pre>

<p>When the program is paused at the breakpoint, type</p>

<pre><code>(dlv) stack
</code></pre>

<p>It will output the current stack trace of the program.  </p>

<pre><code>0  0x00000000010c16e8 in main.max  
   at ./main.go:11
1  0x00000000010c17c9 in main.main  
   at ./main.go:18
2  0x000000000102f754 in runtime.main  
   at /usr/local/Cellar/go/1.13.7/libexec/src/runtime/proc.go:203
3  0x000000000105acc1 in runtime.goexit  
   at /usr/local/Cellar/go/1.13.7/libexec/src/runtime/asm_amd64.s:1357
</code></pre>

<p>So far we have covered basic commands to help start debugging your application using Delve. In the upcoming tutorials, we will cover advanced features of Delve such as debugging goroutines, attaching the debugger to an existing process, remote debugging and also using Delve from the VSCode editor.</p>

<p>Thanks for reading. Please leave your comments and feedback.</p>

<p>Like my tutorials? Please <a href="https://golangbot.com/support-the-content/">support the content</a>.</p>]]></content:encoded></item><item><title><![CDATA[Go Packages]]></title><description><![CDATA[Learn how Go packages work and how to import them in your code. This tutorial also deals with creating custom packages using Go modules.]]></description><link>https://golangbot.com/go-packages/</link><guid isPermaLink="false">d96e6261-7d4f-4ccc-843d-08086eef485f</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sun, 16 Feb 2020 15:11:13 GMT</pubDate><content:encoded><![CDATA[<p><em>This tutorial is for Go version 1.13 or later and uses Go modules. If you are using an older version of Go or looking for the GOPATH version of this tutorial, please visit <a href="https://golangbot.com/packages/">https://golangbot.com/packages/</a>.</em></p>

<p>Welcome to tutorial number 7 in <a href="https://golangbot.com/learn-golang-series/">Golang tutorial series</a>.</p>

<h3 id="whatarepackagesandwhyaretheyused">What are packages and why are they used?</h3>

<p>So far we have seen Go programs that have only one file with a main <a href="https://golangbot.com/functions/">function</a> and a couple of other functions. In real-world scenarios, this approach of writing all source code in a single file is not scalable. It becomes impossible to reuse and maintain code written this way. This is where packages are helpful.</p>

<p><strong>Packages are used to organize Go source code for better reusability and readability. Packages are a collection of Go sources files that reside in the same directory. Packages provide code compartmentalization and hence it becomes easy to maintain Go projects.</strong></p>

<p>For example, let's say we are writing a finance application in Go and some of the functionalities are simple interest calculation, compound interest calculation and loan calculation. One simple way to organize this application is by functionality. We can create packages <code>simpleinterest</code>, <code>compoundinterest</code> and  <code>loan</code>. If the <code>loan</code> package needs to calculate the simple interest, it can simply do so by importing the <code>simpleinterest</code> package. This way the code is reused. </p>

<p>We will learn packages by creating a simple application to determine the simple interest given principal, interest rate and the time duration in years.</p>

<h3 id="mainfunctionandmainpackage">main function and main package</h3>

<p>Every executable Go application must contain the main function. This function is the entry point for execution. The main function should reside in the main package.</p>

<p><strong><code>package packagename</code> specifies that a particular source file belongs to package <code>packagename</code>. This should be the first line of every go source file.</strong></p>

<p>Let's get started by creating the main function and main package for our application. </p>

<p>Run the command below to create a directory named <code>learnpackage</code> inside the current user's <code>Documents</code> directory.</p>

<pre><code>mkdir ~/Documents/learnpackage/  
</code></pre>

<p>Create a file named <code>main.go</code> inside our <code>learnpackage</code> directory with the following contents.</p>

<pre><code class="language-go line-numbers">package main 

import "fmt"

func main() {  
    fmt.Println("Simple interest calculation")
}
</code></pre>

<p>The line of code <code>package main</code> specifies that this file belongs to the main package. The <code>import "packagename"</code> statement is used to import an existing package. <code>packagename.FunctionName()</code> is the syntax to call a function in a package.</p>

<p>In line no. 3, we import the <code>fmt</code> package to use the <code>Println</code> function. The <code>fmt</code> is a standard package and is available inbuilt as a part of the Go standard library. Then there is the main function which prints <code>Simple interest calculation</code></p>

<p>Compile the above program by moving to the <code>learnpackage</code> directory using  </p>

<pre><code>cd ~/Documents/learnpackage/  
</code></pre>

<p>and typing the following command</p>

<pre><code>go install  
</code></pre>

<p>If all went well, our binary will be compiled and will be ready for execution. Type the command <code>learnpackage</code> in the terminal and you will see the following output.</p>

<pre><code>Simple interest calculation  
</code></pre>

<p>If you don't understand how <code>go install</code> works or if you get the error  </p>

<pre><code>go install: no install location for directory /home/naveen/Documents/learnpackage outside GOPATH  
For more details see: 'go help gopath'  
</code></pre>

<p>please visit <a href="https://golangbot.com/hello-world-gomod/">https://golangbot.com/hello-world-gomod/</a> to know more.</p>

<h3 id="gomodule">Go Module</h3>

<p>We will structure the code in such a way that all functionalities related to simple interest are in <code>simpleinterest</code> package. To do that we need to create a custom package <code>simpleinterest</code> which will contain the function to calculate the simple interest. Before creating custom packages, we need to understand <strong><a href="https://golangbot.com/books/">Go Modules</a></strong> first, since <strong>Go Modules</strong> are needed to create custom packages.</p>

<p><strong>A Go Module is nothing but a collection of Go packages.</strong> Now this question might come to your mind. Why do we need Go modules to create a custom package? The answer is <strong>the import path for the custom package we create is derived from the name of the go module</strong>. In addition to this, all the other third-party packages(such as source code from github) which our application uses will be present in the <code>go.mod</code> file along with the version. This <code>go.mod</code> file is created when we create a new module. You will understand this better in the next section.</p>

<p>Another question might popup in our minds. How come we got away without creating a <a href="https://golangbot.com/books/">Go module</a> till now? The answer is, we never created our own custom package till now in this <a href="https://golangbot.com/learn-golang-series/">tutorial series</a> and hence no Go module was needed. </p>

<p>Enough of theory :). Let's get into action and create our go module and custom package.</p>

<h3 id="creatingagomodule">Creating a Go module</h3>

<p>Make sure you are inside the directory <code>learnpackage</code> by typing <code>cd ~/Documents/learnpackage/</code>. Inside this directory run the following command to create a go module named <em>learnpackage</em>.</p>

<pre><code>go mod init learnpackage  
</code></pre>

<p>The above command will create a file named <code>go.mod</code>. The following will be the contents of the file.</p>

<pre><code>module learnpackage

go 1.13  
</code></pre>

<p>The line <code>module learnpackage</code> specifies that the module's name is <code>learnpackage</code>. As we mentioned earlier, <code>learnpackage</code> will be the base path to import any package created inside this module. The line <code>go 1.13</code> specifies that the files in this module use go version <code>1.13</code>.</p>

<h3 id="createthesimpleinterestcustompackage">Create the simple interest custom package</h3>

<p><strong>Source files belonging to a package should be placed in separate folders of their own. It is a convention in Go to name this folder with the same name as the package.</strong></p>

<p>Let's create a folder named <code>simpleinterest</code> inside the <code>learnpackage</code> folder.  <code>mkdir simpleinterest</code> will create this folder for us.</p>

<p>All files inside the <em>simpleinterest</em> folder should start with the line <code>package simpleinterest</code> as they all belong to the <code>simpleinterest</code> package. </p>

<p>Create a file <code>simpleinterest.go</code> inside the <em>simpleinterest</em> folder.</p>

<p>The following will be the directory structure of our application.</p>

<pre><code>â”œâ”€â”€ learnpackage
â”‚Â Â  â”œâ”€â”€ go.mod
â”‚Â Â  â”œâ”€â”€ main.go
â”‚Â Â  â””â”€â”€ simpleinterest
â”‚Â Â      â””â”€â”€ simpleinterest.go
</code></pre>

<p>Add the following code to the <code>simpleinterest.go</code> file.</p>

<pre><code class="language-go line-numbers">package simpleinterest

//Calculate calculates and returns the simple interest for a principal p, rate of interest r for time duration t years
func Calculate(p float64, r float64, t float64) float64 {  
    interest := p * (r / 100) * t
    return interest
}
</code></pre>

<p>In the above code, we have created a function <code>Calculate</code> which calculates and returns the simple interest. This function is self-explanatory. It calculates and returns the simple interest.</p>

<p><em>Note that the function name <strong>Calculate</strong> starts with caps. This is essential and we will explain shortly why this is needed.</em></p>

<h3 id="importingcustompackage">Importing custom package</h3>

<p>To use a custom package we must import it first. The import path is the name of the module appended by the subdirectory of the package and the package name. In our case the module name is <code>learnpackage</code> and the package  <code>simpleinterest</code> is in the <code>simpleinterest</code> folder directly under <code>learnpackage</code>  </p>

<pre><code>â”œâ”€â”€ learnpackage
â”‚   â””â”€â”€ simpleinterest
</code></pre>

<p>So the line <code>import "learnpackage/simpleinterest"</code> will import the <em>simpleinterest</em> package.</p>

<p>In case we have a directory structure like this  </p>

<pre><code>learnpackage  
â”‚Â Â  â””â”€â”€ finance
â”‚Â Â      â””â”€â”€ simpleinterest 
</code></pre>

<p>then the import statement would be <code>import "learnpackage/finance/simpleinterest"</code></p>

<p>Add the following code to <code>main.go</code></p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "learnpackage/simpleinterest"
)

func main() {  
    fmt.Println("Simple interest calculation")
    p := 5000.0
    r := 10.0
    t := 1.0
    si := simpleinterest.Calculate(p, r, t)
    fmt.Println("Simple interest is", si)
}
</code></pre>

<p>The above code imports the <code>simpleinterest</code> package and uses the <code>Calculate</code> function to find the simple interest.  Packages in the standard library don't need the module name prefix and hence "fmt" works without the module prefix. When the application is run, the output will be</p>

<pre><code>Simple interest calculation  
Simple interest is 500  
</code></pre>

<h3 id="abitmoreongoinstall">A bit more on go install</h3>

<p>Now that we understand how packages work, it's time to talk a little bit more about <code>go install</code>. Go tools like <code>go install</code> work in the context of the current directory. Let's understand what that means. Till now we have been running <code>go install</code> from the directory <code>~/Documents/learnpackage/</code>. If we try to run it from any other directory, it will fail.</p>

<p>Try cding into <code>cd ~/Documents/</code> and then running <code>go install learnpackage</code>. It will fail with the following error.</p>

<pre><code>can't load package: package learnpackage: cannot find package "learnpackage" in any of:  
    /usr/local/Cellar/go/1.13.7/libexec/src/learnpackage (from $GOROOT)
    /Users/nramanathan/go/src/learnpackage (from $GOPATH)
</code></pre>

<p>Let's understand the reason behind this error. <code>go install</code> takes an optional package name as a parameter(in our case the package name is <code>learnpackage</code>) and it tries to compile the main function if the package exists in the current directory from which it is run or in the parent directory or it's parent directory and so on. </p>

<p>We are in <code>Documents</code> directory and there is no <code>go.mod</code> file there and hence <code>go install</code> complains that it cannot find the package <code>learnpackage</code>. </p>

<p>When we move to <code>~/Documents/learnpackage/</code>, there is a <code>go.mod</code> file there and our module name is <code>learnpackage</code> in that <code>go.mod</code> file.</p>

<p>so <code>go install learnpackage</code> will work from inside the <code>~/Documents/learnpackage/</code> directory.</p>

<p>But so far we have just been using <code>go install</code> and we did not specify the package name. If no package name is specified, <code>go install</code> will default to the module name in the current working directory. That's why when <code>go install</code> is run without any package name from <code>~/Documents/learnpackage/</code> it worked. So the following 3 commands are equivalent when run from <code>~/Documents/learnpackage/</code></p>

<pre><code>go install

go install .

go install learnpackage  
</code></pre>

<p>I also mentioned that <code>go install</code> has the ability to recursively search the parent directory for a go.mod file. Let's check whether that works.</p>

<pre><code>cd ~/Documents/learnpackage/simpleinterest/  
</code></pre>

<p>The above command will take us to the <code>simpleinterest</code> directory. From that directory run  </p>

<pre><code class="language- ">go install learnpackage  
</code></pre>

<p>Go install will successfully find a <code>go.mod file</code> in the parent directory <code>learnpackage</code> that has the module <code>learnpackage</code> defined and hence it works :).</p>

<h3 id="exportednames">Exported Names</h3>

<p>We capitalized the function <code>Calculate</code> in the Simple interest package. This has a special meaning in Go. Any <a href="https://golangbot.com/variables/">variable</a> or function which starts with a capital letter are exported names in go. Only exported functions and variables can be accessed from other packages. In our case, we want to access <code>Calculate</code> function from the main package. Hence this is capitalized. </p>

<p>If the function name is changed from <code>Calculate</code> to <code>calculate</code> in <code>simpleinterest.go</code>, and if we try to call the function using <code>simpleinterest.calculate(p, r, t)</code> in main.go, the compiler will error </p>

<pre><code># learnpackage
./main.go:13:8: cannot refer to unexported name simpleinterest.calculate
./main.go:13:8: undefined: simpleinterest.calculate
</code></pre>

<p>
Hence if you want to access a function outside of a package, it should be capitalized.</p>

<h3 id="initfunction">init function</h3>

<p>Each package in Go can contain an <code>init</code> function.  The <code>init</code> function must not have any return type and it must not have any parameters. The init function cannot be called explicitly in our source code. It will be called automatically when the package is initialized. The init function has the following syntax</p>

<pre><code class="language-go line-numbers">func init() {  
}
</code></pre>

<p>The <code>init</code> function can be used to perform initialization tasks and can also be used to verify the correctness of the program before the execution starts.</p>

<p>The order of initialization of a package is as follows  </p>

<ol>  
<li>Package level variables are initialised first</li>  
<li>init function is called next. A package can have multiple init functions (either in a single file or distributed across multiple files) and they are called in the order in which they are presented to the compiler.</li>  
</ol>

<p>If a package imports other packages, the imported packages are initialized first. </p>

<p>A package will be initialized only once even if it is imported from multiple packages.</p>

<p>Let's make some modifications to our application to understand <code>init</code> functions.</p>

<p>To start with let's add the <code>init</code> function to the <code>simpleinterest.go</code> file.</p>

<pre><code class="language-go line-numbers">package simpleinterest

import "fmt"

/*
 * init function added
 */
func init() {  
    fmt.Println("Simple interest package initialized")
}
//Calculate calculates and returns the simple interest for principal p, rate of interest r for time duration t years
func Calculate(p float64, r float64, t float64) float64 {  
    interest := p * (r / 100) * t
    return interest
}
</code></pre>

<p>We have added a simple init function which just prints <code>Simple interest package initialised</code></p>

<p>Now let's modify the main package. We know that the principal, rate of interest and time duration should be greater than zero when calculating simple interest. We will define this check using init function and package level variables in the <code>main.go</code> file.</p>

<p>Modify the <code>main.go</code> to the following,</p>

<pre><code class="language-go">package main 

import (  
    "fmt"
    "learnpackage/simpleinterest" //importing custom package
    "log"
)
var p, r, t = 5000.0, 10.0, 1.0

/*
* init function to check if p, r and t are greater than zero
 */
func init() {  
    println("Main package initialized")
    if p &lt; 0 {
        log.Fatal("Principal is less than zero")
    }
    if r &lt; 0 {
        log.Fatal("Rate of interest is less than zero")
    }
    if t &lt; 0 {
        log.Fatal("Duration is less than zero")
    }
}

func main() {  
    fmt.Println("Simple interest calculation")
    si := simpleinterest.Calculate(p, r, t)
    fmt.Println("Simple interest is", si)
}
</code></pre>

<p>The following are the changes made to <code>main.go</code>  </p>

<ol>  
<li><b>p</b>, <b>r</b> and <b>t</b> variables are moved to package level from the main function level.</li>  
<li>An init function has been added. The <i>init</i> function prints a log and terminates the program execution if either the principal, rate of interest or time duration is less than zero using <b>log.Fatal</b> function.</li>  
</ol>

<p>The order of initialisation of the is as follows,  </p>

<ol>  
<li>The imported packages are initialized first. Hence <b>simpleinterest</b> package is initialized first and it's init method is called. </li>  
<li>Package level variables <b>p</b>, <b>r</b> and <b>t</b> are initialized next.</li>  
<li><b>init</b> function is called in main.</li>  
<li><b>main</b> function is called at last.</li>  
</ol>

<p>If you run the program, you will get the following output.</p>

<pre><code>Simple interest package initialized  
Main package initialized  
Simple interest calculation  
Simple interest is 500  
</code></pre>

<p>As expected the init function of the <code>simpleinterest</code> package is called first followed by the initialization of the package level variables <code>p</code>, <code>r</code> and <code>t</code>. The init function of the main package is called next. It checks whether <code>p</code>, <code>r</code> and <code>t</code> are lesser than zero and terminates if the condition is true. We will learn about <code>if</code> statement in detail in a <a href="https://golangbot.com/if-statement/">separate tutorial</a>. For now you can assume that <code>if p &lt; 0</code> will check whether <code>p</code> is less than 0 and if it is, the program will be terminated. We have written a similar condition for <code>r</code> and <code>t</code>. In this case, all these conditions are false and the program execution continues. Finally, the main function is called.</p>

<p>Let's modify this program a bit to learn the use of the init function.</p>

<p>Change the line  </p>

<pre><code>var p, r, t = 5000.0, 10.0, 1.0  
</code></pre>

<p>
in <code>main.go</code> to  </p>

<pre><code>var p, r, t = -5000.0, 10.0, 1.0  
</code></pre>

<p>We have initialised <code>p</code> to negative.</p>

<p>Now if you run the application, you will see  </p>

<pre><code>Simple interest package initialized  
Main package initialized  
2020/02/15 21:25:12 Principal is less than zero  
</code></pre>

<p><em>p</em> is negative. Hence when the init function runs, the program terminates after printing <code>Principal is less than zero</code>.</p>

<h3 id="useofblankidentifier">Use of blank identifier</h3>

<p>It is illegal in Go to import a package and not to use it anywhere in the code. The compiler will complain if you do so. The reason for this is to avoid bloating of unused packages which will significantly increase the compilation time. Replace the code in <code>main.go</code> with the following,</p>

<pre><code class="language-go line-numbers">package main

import (  
        "learnpackage/simpleinterest"
)

func main() {

}
</code></pre>

<p>The above program will error  </p>

<pre><code># learnpackage
./main.go:4:2: imported and not used: "learnpackage/simpleinterest"
</code></pre>

<p>But it is quite common to import packages when the application is under active development and use them somewhere in the code later if not now. The <code>_</code> blank identifier saves us in those situations.</p>

<p>The error in the above program can be silenced by the following code,</p>

<pre><code class="language-go line-numbers">package main

import (  
        "learnpackage/simpleinterest"
)

var _ = simpleinterest.Calculate

func main() {

}
</code></pre>

<p>The line <code>var _ = simpleinterest.Calculate</code> mutes the error. We should keep track of these kinds of error silencers and remove them including the imported package at the end of application development if the package is not used. Hence it is recommended to write error silencers in the package level just after the import statement.</p>

<p>Sometimes we need to import a package just to make sure the initialization takes place even though we do not need to use any function or variable from the package. For example, we might need to ensure that the <code>init</code> function of the <code>simpleinterest</code> package is called even though we plan not to use that package anywhere in our code. The _ blank identifier can be used in this case too as shown below. </p>

<pre><code class="language-go">package main

import (  
    _ "learnpackage/simpleinterest"
)

func main() {

}
</code></pre>

<p>Running the above program will output <code>Simple interest package initialized</code>. We have successfully initialized the <code>simpleinterest</code> package even though it is not used anywhere in the code.</p>

<p>That's it for packages. Hope you enjoyed reading. Please leave your valuable comments and feedback :).</p>

<p>Like my tutorials? Please <a href="https://golangbot.com/support-the-content/">support the content</a>.</p>

<p><strong>Next tutorial - <a href="https://golangbot.com/if-statement/">if else statement</a></strong></p>]]></content:encoded></item><item><title><![CDATA[DIY Pick and Place Robot]]></title><description><![CDATA[Learn how to write firmware for Arduino in Go by creating your own Pick and Place Robot]]></description><link>https://golangbot.com/diy-pick-and-place-robot/</link><guid isPermaLink="false">684f673f-37ac-4764-b028-ad6c699dab4e</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sun, 09 Feb 2020 15:47:51 GMT</pubDate><content:encoded><![CDATA[<p>I am working on a DIY Pick and Place Robot course with my friend <a href="https://www.linkedin.com/in/balajiraghavendra/" target="_"blank"">Balaji</a>. I am taking care of the software side of things while the hardware is taken care by Balaji. </p>

<h3 id="description">Description</h3>

<p>A pick and place robotic system automates the process of picking up parts and placing them in a desired location. These robots plays a major role in industrial automation. The system consists of links, joints &amp; gripper equivalent to a human hand. Each joint in the robot and the gripper contains a separate motor for automating the pick and place operation.</p>

<h3 id="prerequisite">Prerequisite</h3>

<ul>
<li>Basic programming knowledge in Go</li>
<li>No knowledge of electronics is needed. This course is self-sufficient with the electronics knowledge you will need to build the pick and place robot.</li>
<li>This course is also self-sufficient with the Swift and App Inventor knowledge you will need to develop the iOS and Android App </li>
</ul>

<h3 id="whatyouwillbuild">What you will build?</h3>

<iframe width="560" height="315" src="https://www.youtube.com/embed/XfxJD0xnpNA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p><center> <br>
<a class="btn btn-blue btn-md" href="javascript:;" onclick="ml_account('webforms', '1767106', 'q8g8e9', 'show')">Buy the Course Now for $300</a></center></p>

<h4 id="technologystack">Technology Stack</h4>

<ol>
<li>Arduino  </li>
<li>Robotics  </li>
<li>Go  </li>
<li>Swift  </li>
<li>Bluetooth Communication  </li>
<li>App Inventor</li>
</ol>

<h3 id="whatsincludedinthekit">What's included in the kit?</h3>

<p>Pick and place robotic arm kit is a do it yourself kit for hobbyist aimed at providing hands on experience in developing a full fledged robotic arm with 6 degrees of freedom (6 Motors). The kit is bundled with all the necessary mechanical components, electronic components and assembly instructions for building the robot. It also includes a detailed tutorial for developing connectivity between the robotic arm and Arduino using Go. We will also be developing an Android and iOS application to talk with the Arduino and control the robotic arm from a mobile device using Bluetooth.</p>

<p><img src="https://golangbot.com/content/images/2020/02/architecture.png" alt="architecture"></p>

<table>  
<tr>  
<th>S.No</th>  
<th>Assembly</th>  
<th>Part Name</th>  
<th>Technical Specification</th>  
<th>Qty</th>  
</tr>  
<tr>  
<td>1</td>  
<td rowspan="6">Mechanical</td>  
<td>Base</td>  
<td>Plastic â€“ 3D Printed</td>  
<td>1</td>  
</tr>  
<tr>  
<td>2</td>  
<td>Waist</td>  
<td>Plastic â€“ 3D Printed</td>  
<td>1</td>  
</tr>  
<tr>  
<td>3</td>  
<td>Shoulder</td>  
<td>Plastic â€“ 3D Printed</td>  
<td>1</td>  
</tr>  
<tr>  
<td>4</td>  
<td>Elbow</td>  
<td>Plastic â€“ 3D Printed</td>  
<td>1</td>  
</tr>  
<tr>  
<td>5</td>  
<td>Wrist</td>  
<td>Plastic â€“ 3D Printed</td>  
<td>1</td>  
</tr>  
<tr>  
<td>6</td>  
<td>Gripper</td>  
<td>Plastic â€“ 3D Printed</td>  
<td>1</td>  
</tr>  
<tr>  
<td>7</td>  
<td rowspan="2">Motor</td>  
<td>Servo Motor 1</td>  
<td>3 Wire Servo Motor<br>  
Operating Voltage: 4.8 V â€“ 6.6 V<br>  
Stall Torque: 9.4 kg-cm (4.8V);  
11 kg-cm (6.0 V)  
</td>  
<td>1</td>  
</tr>  
<tr>  
<td>8</td>  
<td>Servo Motor 2</td>  
<td>3 Wire Servo Motor<br>  
Operating Voltage: 4.8 V â€“ 6.6 V<br>  
Stall Torque: 1.8 kg-cm (4.8V); 2.2 kg-cm (6.6V)  
</td>  
<td>1</td>  
</tr>  
<tr>  
<td>9</td>  
<td rowspan="2">Power Supply</td>  
<td rowspan="2">Power Adapter</td>  
<td>Power Rating: 5V, 4A</td>  
<td>1</td>  
</tr>  
<tr>  
<td>10</td>  
<td>Power Rating: 5V, 4A</td>  
<td>1</td>  
</tr>  
<tr>  
<td>11</td>  
<td rowspan="2">Accessories</td>  
<td>Jumper Wire</td>  
<td>Type: Male to Female, Length: 20 CM</td>  
<td>1 Set</td>  
</tr>  
<tr>  
<td>12</td>  
<td rowspan="2">Screws</td>  
<td>Metal Screws</td>  
<td>1 Set</td>  
</tr>  
</table>

<p><img src="https://golangbot.com/content/images/2020/02/Overall-System.JPG" alt="pick and place robot"></p>

<h3 id="whatyouwilllearn">What you will learn?</h3>

<ol>
<li>Basics of Robotic arm, Servo motor, Arduino, Bluetooth module &amp; Serial communication.  </li>
<li>Interfacing Robotic arm, Arduino &amp; Bluetooth module  </li>
<li>Implementing robotic arm control modes: Manual mode &amp; Teach and repeat mode  </li>
<li>Developing firmware in Go using <a href="https://gobot.io/" target="_"blank"">https://gobot.io/</a>  </li>
<li>Developing android application through App inventor  </li>
<li>Developing iOS application using Swift</li>
</ol>

<p><center> <br>
<a class="btn btn-blue btn-md" href="javascript:;" onclick="ml_account('webforms', '1767106', 'q8g8e9', 'show')">Buy the Course Now for $300</a></center></p>]]></content:encoded></item><item><title><![CDATA[Hello World]]></title><description><![CDATA[Learn to compile and run a simple hello world program using Go. You will learn how to run the program using go install, go build and go run. ]]></description><link>https://golangbot.com/hello-world-gomod/</link><guid isPermaLink="false">8038cba3-265c-4ca2-8a33-aaa1e2796de1</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sun, 30 Jan 2022 08:48:00 GMT</pubDate><content:encoded><![CDATA[<p>This is the second tutorial in our <a href="https://golangbot.com/learn-golang-series/">Golang tutorial series</a>. Please read our previous tutorial <a href="https://golangbot.com/golang-tutorial-part-1-introduction-and-installation/">Golang Introduction and Installation</a> to know about what is Golang and how to install Golang.</p>

<p><em>This tutorial is for Go version 1.13 or later. If you are using an older version, please visit <a href="https://golangbot.com/hello-world/">https://golangbot.com/hello-world/</a>.</em></p>

<p>There is no better way to learn a programming language than getting our hands dirty with code. Let's go ahead and write our first Go program. </p>

<h3 id="settingupthedevelopmentenvironment">Setting up the development environment</h3>

<p>Let's create a directory where we want to write our hello world program. Open the terminal and run the following command.</p>

<pre><code>mkdir ~/Documents/learngo/  
</code></pre>

<p>The above command will create a directory named <code>learngo</code> inside the current user's Documents directory. Feel free to create the directory wherever you want the code to reside. </p>

<h3 id="creatingagomodule">Creating a Go Module</h3>

<p>Go modules are used to track our application's dependencies and their versions. Next step is to create a go module named <code>learngo</code> in the <code>~/Documents/learngo/</code> folder. </p>

<p>Run <code>go mod init learngo</code> inside the <code>~/Documents/learngo/</code> directory. This will create a file named <code>go.mod</code>. The contents of the file are provided below.</p>

<pre><code class="language-go line-numbers">module learngo

go 1.17  
</code></pre>

<p>The first line <code>module learngo</code> specifies the module name. The next line <code>go 1.17</code> indicates that the files in this module use go version 1.17</p>

<p>We will discuss Go modules in more detail when we learn about <a href="https://golangbot.com/go-packages/">packages</a>.</p>

<h3 id="helloworld">Hello World</h3>

<p>Create a file named <code>main.go</code> in the <code>learngo</code> directory using your favourite text editor with the following contents.</p>

<pre><code class="language-go line-numbers">package main

import "fmt"

func main() {  
    fmt.Println("Hello World")
} 
</code></pre>

<p>It's a convention in Go to name the file that contains the <code>main</code> function as <code>main.go</code>, but other names work as well.</p>

<h3 id="runningagoprogram">Running a go program</h3>

<p>There are a couple of different ways to run a Go program. Let's look at them one by one.</p>

<h4 id="1goinstall">1. go install</h4>

<p>The first method to run a Go program is using the <code>go install</code> command. <br>
Let's <code>cd</code> into the <code>learngo</code> directory we just created. </p>

<pre><code>cd ~/Documents/learngo/  
</code></pre>

<p>Run the following command next.</p>

<pre><code>go install  
</code></pre>

<p>The above command will compile the program and install(copy) the binary to location <code>~/go/bin</code>. The name of the binary will be the folder containing <code>main.go</code>. In our case, it will be named <code>learngo</code>.</p>

<p>You might encounter the following error when you try to install the program.</p>

<pre><code>go install: no install location for directory /home/naveen/Documents/learngo outside GOPATH  
For more details see: 'go help gopath'  
</code></pre>

<p>What the above error actually means is, <code>go install</code> is unable to find a location to install the compiled binary. So let's go ahead and give it a location. This location is governed by the <code>GOBIN</code> environment variable. </p>

<pre><code>export GOBIN=~/go/bin/  
</code></pre>

<p>The above command specifies that <code>go install</code> should copy the compiled binary to the path <code>~/go/bin/</code>. This is the conventional location for a Go binary but feel free to change it to any location you want. Now try running <code>go install</code> again and the program should compile and run without any problems.</p>

<p>You can type <code>ls -al ~/go/bin/learngo</code> in the terminal and you can find that in fact <code>go install</code> has placed the binary in the path <code>~/go/bin</code></p>

<p>Now let's run the compiled binary.</p>

<pre><code>~/go/bin/learngo
</code></pre>

<p>
The above command will run the <code>learngo</code> binary and print the following output.</p>

<pre><code>Hello World  
</code></pre>

<p>Congrats! You have successfully run your first Go Program.</p>

<p>If you want to avoid typing the entire path <code>~/go/bin/learngo</code> each time you run the program, you can add <code>~/go/bin/</code> to your PATH.</p>

<pre><code>export PATH=$PATH:~/go/bin  
</code></pre>

<p>Now you can just type <code>learngo</code> in the terminal to run the program. </p>

<p>You might be wondering what will happen when the <code>learngo</code> directory contains muliple go files instead of just <code>main.go</code>. How will <code>go install</code> work in this case? Please hold on, we will discuss these when we learn about <a href="https://golangbot.com/go-packages/">packages and go modules</a>.</p>

<h4 id="2gobuild">2. go build</h4>

<p>The second option to run the program is using <code>go build</code>. <code>go build</code> is much similar to <code>go install</code> except that it doesn't install(copy) the compiled binary to the path <code>~/go/bin/</code>, rather it creates the binary inside the location from which <code>go build</code> was installed.</p>

<p>Type the following command in the terminal </p>

<pre><code>cd ~/Documents/learngo/  
</code></pre>

<p>to change the current directory to <code>learngo</code>. </p>

<p>After that, enter the following command. </p>

<pre><code>go build  
</code></pre>

<p>The above command will create a binary named <code>learngo</code> in the current directory. <code>ls -al</code> will reveal that a file named <code>learngo</code> is created.</p>

<p>Type <code>./learngo</code> to run the program. This will also print</p>

<pre><code>Hello World  
</code></pre>

<p>We have successfully run our first Go program using <code>go build</code> too :)</p>

<h4 id="3gorun">3. go run</h4>

<p>The third way to run the program is using <code>go run</code> command.</p>

<p>Type the command <code>cd ~/Documents/learngo/</code> in the terminal to change the current directory to <code>learngo</code>. </p>

<p>After that, enter the following command. </p>

<pre><code>go run main.go  
</code></pre>

<p>After the above command is entered, we can see the output</p>

<pre><code>Hello World  
</code></pre>

<p>One subtle difference between the <code>go run</code> and <code>go build/go install</code> commands is, <code>go run</code> requires the name of the <code>.go</code> file as an argument.</p>

<p>Under the hood, <code>go run</code> works much similar to <code>go build</code>. Instead of compiling and installing the program to the current directory, it compiles the file to a temporary location and runs the file from that location. If you are interested to know the location where <code>go run</code> compiles the file to, please run <code>go run</code> with the <code>--work</code> argument. </p>

<pre><code>go run --work main.go  
</code></pre>

<p>Running the above command in my case outputs</p>

<pre><code>WORK=/var/folders/23/vdjz4kt972g5nzr86wzrj9740000gq/T/go-build698353814  
Hello World  
</code></pre>

<p>The <code>WORK</code> key's value specifies the temporary location to which the program will be compiled. <br>
In my case, the program has been compiled to the location <code>/var/folders/23/vdjz4kt972g5nzr86wzrj9740000gq/T/go-build698353814/b001/exe</code>. This might vary in your case :)</p>

<h4 id="4goplayground">4. Go Playground</h4>

<p>The final way of running the program is using the go playground. Although this has restrictions, this method comes in handy when we want to run simple programs since it uses the browser and doesn't need Go installed in your local :). I have created a playground for the hello world program. <a href="https://go.dev/play/p/oXGayDtoLPh" target=" _blank">Click here</a> to run the program online.</p>

<p>You can also use the go playground to share your source code with others.</p>

<p>Now that we know 4 different ways to run a program, you might be in a confusion to decide which method to use. The answer is, it depends. I generally use the <a href="https://go.dev/play/p/oXGayDtoLPh" target=" _blank">playground</a> when I want to do a quick check of logic or find out how a standard library function works. In most other cases, I prefer <code>go install</code> since it gives me an option to run the program from any directory in the terminal as it compiles all programs to the standard <code>~/go/bin/</code> path.</p>

<h4 id="ashortexplanationofthehelloworldprogram">A short explanation of the hello world program</h4>

<p>Here is the hello world program we just wrote</p>

<pre><code class="language-go">package main 

import "fmt" 

func main() {  
    fmt.Println("Hello World") 
}
</code></pre>

<p>We will discuss in brief what each line of the program does. We will dwell deep into each section of the program in the upcoming tutorials.</p>

<p><strong>package main</strong> -  <strong>Every go file must start with the <code>package name</code> statement.</strong> Packages are used to provide code compartmentalization and reusability. The package name  <strong><code>main</code></strong> is used here. The main function should always reside in the main package.</p>

<p><strong>import "fmt"</strong> - The import statement is used to import other packages. In our case, <code>fmt</code> package is imported and it will be used inside the main function to print text to the standard output.</p>

<p><strong>func main()</strong> - The <code>func</code> keyword marks the beginning of a function. The <code>main</code> is a special function. The program execution starts from the <code>main</code> function. The <code>{</code> and <code>}</code> braces indicate the start and end of the main function.</p>

<p><strong>fmt.Println("Hello World")</strong> - The <code>Println</code> function of the <code>fmt</code> package is used to write text to the standard output. <code>package.Function()</code> is the syntax to call a function in a package.</p>

<p>The code is available for download at <a href="https://github.com/golangbot/hello" target="_blank">github</a>.</p>

<p>You can now move on to <a href="https://golangbot.com/variables/">Golang tutorial part 3: Variables</a> to learn about variables in Go.</p>

<p>Please post your feedback and queries in the comments section. Thank you.</p>

<p><strong>Next Tutorial - <a href="https://golangbot.com/variables/">Variables</a></strong></p>]]></content:encoded></item><item><title><![CDATA[June 2019 Quiz Answers and Explanation]]></title><description><![CDATA[<p>Here are all the quizzes posted on <a href="https://twitter.com/bot_golang " target="_"blank"">Twitter</a> and <a href="https://www.facebook.com/golangbot " target="_"blank"">Facebook</a> in June 2019 and their explanation.</p>

<h3 id="quiz1">Quiz 1</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func hello() []string {  
    return nil
}

func main() {  
    h := hello
    if h == nil {
        fmt.Println("nil")
    } else {
        fmt.Println("not nil")
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/tJ01sLBMgcY " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>nil  
not nil  
compilation</code></pre>]]></description><link>https://golangbot.com/june-2019-quiz-results/</link><guid isPermaLink="false">91af2ae2-3639-4409-b304-28d5cf0effed</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Fri, 16 Aug 2019 11:54:55 GMT</pubDate><content:encoded><![CDATA[<p>Here are all the quizzes posted on <a href="https://twitter.com/bot_golang " target="_"blank"">Twitter</a> and <a href="https://www.facebook.com/golangbot " target="_"blank"">Facebook</a> in June 2019 and their explanation.</p>

<h3 id="quiz1">Quiz 1</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func hello() []string {  
    return nil
}

func main() {  
    h := hello
    if h == nil {
        fmt.Println("nil")
    } else {
        fmt.Println("not nil")
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/tJ01sLBMgcY " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>nil  
not nil  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>not nil  
</code></pre>

<p>We assign the <a href="https://golangbot.com/functions/">function</a> <code>hello</code> to the variable <code>h</code> and not the return value of <code>hello()</code> in line no. 12 and hence <code>h</code> is not nil and the program will print <code>not nil</code>. </p>

<h3 id="quiz2">Quiz 2</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "strconv"
)

func main() {  
    i := 2 
    s := "1000"
    if len(s) &gt; 1 {
        i, _ := strconv.Atoi(s)
        i = i + 5
    }
    fmt.Println(i)
}
</code></pre>

<p><a href="https://play.golang.org/p/JSYBA802GnC " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>2  
1005  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>2  
</code></pre>

<p>The tricky part of the above quiz is line no. 12. <code>i, _ := strconv.Atoi(s)</code> creates a new <a href="https://golangbot.com/variables/">variable</a> <code>i</code> whose scope is only within the <code>if</code> statement. The <code>i</code> which is being printed in line no. 15 is actually the one defined in line no. 9 and not the one defined in line no. 12. Hence this program will print <code>2</code>.</p>

<h3 id="quiz3">Quiz 3</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func hello(num ...int) {  
    num[0] = 18
}

func main() {  
    i := []int{5, 6, 7}
    hello(i...)
    fmt.Println(i[0])
}
</code></pre>

<p><a href="https://play.golang.org/p/cZntEjI8FWF " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>18  
5  
Compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>18  
</code></pre>

<p>The slice <code>i</code> is passed to the variadic function <code>hello()</code> function in line no. 13.  To know why this happens, please read the section <strong>Passing a slice to a variadic function</strong> in <a href="https://golangbot.com/variadic-functions/">https://golangbot.com/variadic-functions/</a>. </p>

<p>If you read the section <strong>Passing a slice to a function</strong> in <a href="https://golangbot.com/arrays-and-slices/">https://golangbot.com/arrays-and-slices/</a>, you can understand that changes made to a slice inside a function are visible to the caller. Hence line no. 14 will print <code>18</code>.</p>

<h3 id="quiz4">Quiz 4</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    a := [2]int{5, 6}
    b := [2]int{5, 6}
    if a == b {
        fmt.Println("equal")
    } else {
        fmt.Println("not equal")
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/VCvoUpz5gQE " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>compilation error  
equal  
not equal  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>equal  
</code></pre>

<p>Arrays are value types in Go and can be compared. Two array values are equal if their corresponding elements are equal. In our case, <code>a</code> and <code>b</code> are equal and hence this program prints <code>equal</code>.</p>

<h3 id="quiz5">Quiz 5</h3>

<pre><code class="language-go line-numbers">package main

import "fmt"

type rect struct {  
    len, wid int
}

func (r rect) area() {  
    fmt.Println(r.len * r.wid)
}

func main() {  
    r := &amp;rect{len: 5, wid: 6}
    r.area()
}
</code></pre>

<p><a href="https://play.golang.org/p/lWInbBmCh7a " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>compilation error  
30  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>30  
</code></pre>

<p>This program will compile perfectly and print <code>30</code>. </p>

<p>In line no. 14 of the program above, we assign the address of <code>rect</code> to <code>r</code>. You might be wondering why the program worked when we didn't use <code>(*r).area()</code> in line no. 15. Since <code>area()</code> has a value receiver, Go is intelligent enough to interpret <code>r.area()</code>  as <code>(*r).area()</code> and hence this program works :).</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="quiz6">Quiz 6</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    a := [5]int{1, 2, 3, 4, 5}
    t := a[3:4:4]
    fmt.Println(t[0])
}
</code></pre>

<p><a href="https://play.golang.org/p/z3KqBXFXMm3 " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>3  
4  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>4  
</code></pre>

<p>The expression</p>

<pre><code>a[low : high : max]  
</code></pre>

<p>constructs a slice of the same type, and with the same length and elements as the simple slice expression a[low : high]. Additionally, it controls the resulting slice's capacity by setting it to max - low. Hence, the slice <code>t</code> in line no.9 has one element <code>4</code> and is of capacity <code>1</code>. </p>

<h3 id="quiz7">Quiz 7</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

type person struct {  
    name string
}

func main() {  
    var m map[person]int
    p := person{"mike"}
    fmt.Println(m[p])
}
</code></pre>

<p><a href="https://play.golang.org/p/81IfUlfNAJu " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>compilation error  
0  
1  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>0  
</code></pre>

<p>When we try to print an element that does not exist in a <a href="https://golangbot.com/maps/">map</a>, the zero value of the element is printed. In our case <code>m</code> is a map of type <code>map[person]int</code>. Since <code>p</code> doesn't exist in the map, the zero value of int i.e <code>0</code> is printed.</p>

<h3 id="quiz8">Quiz 8</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    i := 65
    fmt.Println(string(i))
}
</code></pre>

<p><a href="https://play.golang.org/p/lYfJ6qOVMJV " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>A  
65  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>A  
</code></pre>

<p>The unicode value of <code>A</code> is <code>65</code>. Hence when <code>i</code> is <em>type casted</em> to <a href="https://golangbot.com/strings/">string</a> in line no. 9, <code>A</code> is printed.</p>

<h3 id="quiz9">Quiz 9</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    a := 5
    b := 8.1
    fmt.Println(a + b)
}
</code></pre>

<p><a href="https://play.golang.org/p/0-Xm6wZPxfw " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>13.1  
13  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>compilation error  
</code></pre>

<p>a is of type <code>int</code> and b is of type <code>float64</code>. We are trying to add a <code>int</code> and <code>float64</code> in line no. 10. This is not allowed and hence the program will fail to compile with error <em>./prog.go:10:16: invalid operation: a + b (mismatched types int and float64)</em></p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="quiz10">Quiz 10</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    var i interface{}
    if i == nil {
        fmt.Println("nil")
        return
    }
    fmt.Println("not nil")
}
</code></pre>

<p><a href="https://play.golang.org/p/CTaIzWteuQe " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>nil  
not nil  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>nil  
</code></pre>

<p>An empty <a href="https://golangbot.com/interfaces-part-1/">interface</a> has both its underlying value and concrete type as <code>nil</code>. Hence <code>i</code> is <code>nil</code>.</p>

<h3 id="quiz11">Quiz 11</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func hello(i int) {  
    fmt.Println(i)
}
func main() {  
    i := 5
    defer hello(i)
    i = i + 10
}
</code></pre>

<p><a href="https://play.golang.org/p/hMcMm9tJw2k " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>5  
15  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>5  
</code></pre>

<p>The arguments of a <a href="https://golangbot.com/defer/">deferred</a> function are evaluated when the defer statement is executed and not when the actual function call is done. Hence when the defer statement is encountered in line no. 12, the value of <code>i</code> is 5. So this program will print <code>5</code>.</p>

<h3 id="quiz12">Quiz 12</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    fmt.Printf("%%")
}
</code></pre>

<p><a href="https://play.golang.org/p/DbXWTaehulR " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>0.0  
compilation error  
%
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>%
</code></pre>

<p>The format specifier <code>%%</code> prints a literal <code>%</code> sign. Hence the program prints <code>%</code>.</p>

<h3 id="quiz13">Quiz 13</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    s := make(map[string]int)
    delete(s, "h")
    fmt.Println(s["h"])
}
</code></pre>

<p><a href="https://play.golang.org/p/mff73_BrPqH " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>runtime panic  
0  
compilation error  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>0  
</code></pre>

<p>The delete function in line no. 9 doesn't return anything and will do nothing if the specified key doesn't exist. Since the key <code>h</code> doesn't exist, the delete function will not do anything. In line no. 10, we are trying to print <code>s["h"]</code>. Since the map <code>s</code> doesn't have the key <code>h</code>, it will return the default value of <code>int</code>. Hence <code>0</code> will be printed.</p>

<h3 id="quiz14">Quiz 14</h3>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
)

func main() {  
    i := -5
    j := +5
    fmt.Printf("%+d %+d", i, j)
}
</code></pre>

<p><a href="https://play.golang.org/p/J5hHQyHDPVQ " target="_"blank"">Run in playground</a></p>

<h5 id="options">Options</h5>

<pre><code>-5 +5
+5 +5
0 0  
</code></pre>

<h5 id="answer">Answer</h5>

<pre><code>-5 +5
</code></pre>

<p>The <code>+</code> flag in the format specifier <code>%+d</code> is used to always print a sign for numeric values. Hence this program outputs <code>-5 +5</code>.</p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>]]></content:encoded></item><item><title><![CDATA[Resumable file uploader: Testing the server using curl and dd  commands]]></title><description><![CDATA[In this tutorial we will use the curl and dd commands to test our resumable file upload server.]]></description><link>https://golangbot.com/resumable-file-uploader-testing-the-server-using-curl-dd/</link><guid isPermaLink="false">69110a09-3b56-46c4-af38-16d54f3f8235</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sat, 19 Jun 2021 00:59:00 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 4 in our <a href="https://golangbot.com/resumable-file-uploader/">Resumable file uploader series</a>.</p>

<p>In the previous tutorials, we coded our resumable tus server using Go. In this tutorial we will use <a href="https://curl.haxx.se/docs/manpage.html" target="_"blank"">curl</a> and <a href="http://man7.org/linux/man-pages/man1/dd.1.html" target="_"blank"">dd</a> commands to test the tus server.</p>

<h3 id="testing">Testing</h3>

<p>We have the resumable file upload tus server ready but we have not tested it yet. We need a tus client to test the tus server. We will create the Go client in the upcoming tutorials. For now, we will use the <a href="https://curl.haxx.se/" target="_"" blank"="">curl</a> command to test the tus server.</p>

<p>Let's run the server first. Run the following commands in the terminal to fetch the code from github and then to run it.</p>

<pre><code class="language-go line-numbers">go get github.com/golangbot/tusserver  
go install github.com/golangbot/tusserver  
tusserver  
</code></pre>

<p>After running the above commands, the server will be up and running.</p>

<pre><code>2019/03/30 18:01:41 Connection established successfully  
2019/03/30 18:01:41 TUS Server started  
2019/03/30 18:01:41 Directory created successfully  
2019/03/30 18:01:41 table create successfully  
</code></pre>

<p>We need a file to test the tus server. I have made a collage video of my pet and it is available at <a href="https://www.dropbox.com/s/evchz5hsuvtrvuu/mypet.mov?dl=0" target="_blank">https://www.dropbox.com/s/evchz5hsuvtrvuu/mypet.mov?dl=0</a>. Please feel free to use it :). I have downloaded the video to my <code>~/Downloads</code> directory.</p>

<p>Let's send a <code>post</code> request and create a new file. We need to specify the <code>Upload-Length</code> of the entire file in the post request. This is nothing but the size of the file. We can use the <code>ls</code> command to find the size of the file </p>

<pre><code>ls -al ~/Downloads/mypet.mov  
</code></pre>

<p>The above command returns the following output.</p>

<pre><code>-rw-rw-r-- 1 naveen naveen 11743398 Mar 31 11:11 /home/naveen/Downloads/mypet.mov
</code></pre>

<p><em>11743398</em> is the size of the file. Now that we know the Upload-Length, let's create the file by sending a post request.</p>

<pre><code>curl --request POST  localhost:8080/files --header "Upload-Length: 11743398" -i  
</code></pre>

<p>The above command creates the file. The <code>-i</code> argument in the end is used to display the response headers. The above command will return the following result.</p>

<pre><code>HTTP/1.1 201 Created  
Location: localhost:8080/files/1  
Date: Sun, 31 Mar 2019 07:47:33 GMT  
Content-Length: 0  
</code></pre>

<p>The file creation has been created successfully. </p>

<p>Now comes the tricky part. <em>How do we test the tus server by simulating a network disconnection?</em> If we send a patch request to the file URL using curl, the request will be completed immediately since the server is running locally and we will not be able to test whether the server is able to handle resumable uploads.</p>

<p>This is where the <code>--limit-rate</code> argument of curl helps us. This argument can be used to rate limit the patch file request.</p>

<pre><code>curl --request PATCH --data-binary "@/home/naveen/Downloads/mypet.mov" localhost:8080/files/1 --header "Upload-Offset: 0" --header "Expect:" -i --limit-rate 200K  
</code></pre>

<p>In the curl request above, we are sending a patch request to the file at location <code>localhost:8080/files/1</code> and <code>Upload-Offset: 0</code> and we are rate-limiting the request to <em>200KB/Sec</em>. The contents of <code>mypet.mov</code> is added to the request body. The <code>--header "Expect:"</code> header is needed to prevent curl from sending <code>Expect: 100-continue</code> header. Please read <a href="https://gms.tf/when-curl-sends-100-continue.html" target="_"blank"">https://gms.tf/when-curl-sends-100-continue.html</a> to know why this is needed.</p>

<p>After issuing the above patch request, the file will be transferred at 200KB/S. Let the request run for a few seconds, say 10 seconds. After approximately 10 seconds, please stop the request by pressing <code>ctrl + c</code>. Now we have terminated the patch request in the middle. The server should have stored the bytes transferred till now. Let's check whether it has done it. </p>

<p>Move to the server logs and you will be able to see the following in the log,</p>

<pre><code>2019/03/31 13:36:00 Received file partially unexpected EOF  
2019/03/31 13:36:00 Size of received file  1589248  
2019/03/31 13:36:00 number of bytes written  1589248  
</code></pre>

<p><em>The size of the received file may be different for you. The above is my output.</em></p>

<p>hmm looks like it has saved the bytes received till now. But how do we verify it? Well, let's check the size of the uploaded file.</p>

<pre><code>ls -al ~/fileserver/1  
</code></pre>

<p>Running the above command outputs</p>

<pre><code>-rw-r--r-- 1 naveen naveen 1589248 Mar 31 13:36 /home/naveen/fileserver/1
</code></pre>

<p>The size of the file matches the server output. Now we can be 100% sure that the server has saved the bytes it has received. If you try to play the video now, it won't play since the file is still not completely uploaded yet.</p>

<p>The next step is to continue the patch request from where it stopped. We first needed to know the Upload-Offset so that we can issue the next patch request. This is where the head request comes in handy.</p>

<pre><code>curl --head localhost:8080/files/1 -i  
</code></pre>

<p>The above curl command will return the <code>Upload-Offset</code></p>

<pre><code>HTTP/1.1 200 OK  
Upload-Offset: 1589248  
Date: Sun, 31 Mar 2019 08:17:28 GMT  
</code></pre>

<p>Note that the offset matches the server logs and the file size.</p>

<p>Now we need to send a <code>PATCH</code> request with the above upload offset. One more concern is we need to send the file data(bytes of the file) from this offset only, not the entire file.</p>

<p>This is where the <a href="http://man7.org/linux/man-pages/man1/dd.1.html" target="_blank"">dd</a> command helps us. </p>

<pre><code>dd if=/home/naveen/Downloads/mypet.mov skip=1589248 bs=1 | curl --request PATCH --data-binary @- localhost:8080/files/1 --header "Upload-Offset: 1589248" --header "Expect:" -i  
</code></pre>

<p>In the above command, we use <code>if</code> to specify the input file and <code>skip</code> is used to skip <code>1589248</code> bytes. <code>1589248</code> is our <code>Upload-Offset</code>. <code>bs</code> specifies that we read one byte at a time. We pipe the output of <code>dd</code> to <code>curl</code> command. After running the above command, we will get the output</p>

<pre><code>HTTP/1.1 204 No Content  
Upload-Offset: 11743398  
Date: Sun, 31 Mar 2019 08:25:10 GMT  
</code></pre>

<p>A 204 No Content indicates that the patch was successful. To know whether the file upload is complete, we can again issue a head request and the upload offset should match the upload length(size) of the file.</p>

<pre><code>curl --head localhost:8080/files/1 -i  
</code></pre>

<p>The above command will output </p>

<pre><code>HTTP/1.1 200 OK  
Upload-Offset: 11743398  
Date: Sun, 31 Mar 2019 08:30:54 GMT  
</code></pre>

<p>The upload offset matches the upload length and we are sure that the file has been uploaded completely. Now if you try to issue a patch request again, the server will complain saying that the upload is already complete.</p>

<p>Let's again check the file size now.</p>

<pre><code>ls -al ~/fileserver/1  
</code></pre>

<p>Running the above command outputs</p>

<pre><code>-rw-r--r-- 1 naveen naveen 11743398 Mar 31 13:55 /home/naveen/fileserver/1
</code></pre>

<p>The file size in the output matches the upload length and this confirms that the file has been uploaded completely. You can go ahead and play the video and it will play now :)</p>

<p>Our resumable tus server is ready :)</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="enhancements">Enhancements</h3>

<p>Although the file uploader works, this code needs to refactored further. It currently doesn't handle concurrency. For instance, we might hit a race condition when multiple clients send a concurrent patch request for the same file and at the same offset. </p>

<p>This code also doesn't handle DB transactions well. There is a chance that a POST request to create a file might end up creating the file in the DB but not creating the actual file in the file system. For example, what happens when there is no space left in the file system.</p>

<p>All the code is currently present in the main package in a single file and this approach is not extensible. The code has to be refactored into usable packages. One approach to structure code in Go is using Domain Driven Design.</p>

<p>We also don't have a tus client ready yet :).  </p>

<p>All these will be addressed in the upcoming tutorials. I hope you enjoyed reading. Please leave your comments. Have a good day.</p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>]]></content:encoded></item><item><title><![CDATA[Resumable file uploader: Creating http handlers]]></title><description><![CDATA[In this tutorial we create the GET, POST and PATCH handlers needed for implementing the tus server using Go.]]></description><link>https://golangbot.com/resumable-file-uploader-creating-http-handlers/</link><guid isPermaLink="false">dd5aec41-8a78-4178-9807-5b0384786a4f</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Fri, 18 Jun 2021 00:59:00 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 3 in our <a href="https://golangbot.com/resumable-file-uploader/">Resumable file uploader series</a>.</p>

<p>The <a href="https://golangbot.com/resumable-file-uploader/">previous tutorials</a> provided an introduction about the tus protocol and we also created the <a href="https://golangbot.com/resumable-file-uploader-implementing-db-crud-methods">DB CRUD</a> methods. </p>

<p>In this tutorial, we will create the http handlers to support the <code>POST</code>, <code>PATCH</code> and <code>HEAD</code> http methods.</p>

<p>This tutorial has the following sections</p>

<ul>
<li>POST http handler</li>
<li>HEAD http handler</li>
<li>PATCH http handler
<ul><li>File validation</li>
<li>Upload complete validation</li>
<li>Upload offset validation</li>
<li>Content length validation</li>
<li>File patch</li></ul></li>
</ul>

<h3 id="posthttphandler">POST http handler</h3>

<p>Before we create the POST handler, we need a directory to store the files. For simplicity, we are going to create a directory named <code>fileserver</code> inside the <code>home</code> directory to store the files.</p>

<pre><code class="language-go line-numbers">const dirName="fileserver"

func createFileDir() (string, error) {  
    u, err := user.Current()
    if err != nil {
        log.Println("Error while fetching user home directory", err)
        return "", err
    }
    home := u.HomeDir
    dirPath := path.Join(home, dirName)
    err = os.MkdirAll(dirPath, 0744)
    if err != nil {
        log.Println("Error while creating file server directory", err)
        return "", err
    }
    return dirPath, nil
}
</code></pre>

<p>In the above function, we get the current user's name and home directory and append <code>dirName</code> constant to create the directory. This function will return the path of the newly created directory or errors if any.</p>

<p>This function will be called from main and the <code>dirPath</code> returned from this function will be used by the POST file handler to create the file.</p>

<p>Now that we have the directory ready, let's move to the POST http handler. We will name this handler <code>createFileHandler</code>. The <code>POST</code> http handler is used to create a new file and return the location of the newly created file in the <code>Location</code> header. It is mandatory for the request to contain a <code>Upload-Length</code> header indicating the entire file size. </p>

<pre><code class="language-go line-numbers">func (fh fileHandler) createFileHandler(w http.ResponseWriter, r *http.Request) {  
    ul, err := strconv.Atoi(r.Header.Get("Upload-Length"))
    if err != nil {
        e := "Improper upload length"
        log.Printf("%s %s", e, err)
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(e))
        return
    }
    log.Printf("upload length %d\n", ul)
    io := 0
    uc := false
    f := file{
        offset:         &amp;io,
        uploadLength:   ul,
        uploadComplete: &amp;uc,
    }
    fileID, err := fh.createFile(f)
    if err != nil {
        e := "Error creating file in DB"
        log.Printf("%s %s\n", e, err)
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    filePath := path.Join(fh.dirPath, fileID)
    file, err := os.Create(filePath)
    if err != nil {
        e := "Error creating file in filesystem"
        log.Printf("%s %s\n", e, err)
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    defer file.Close()
    w.Header().Set("Location", fmt.Sprintf("localhost:8080/files/%s", fileID))
    w.WriteHeader(http.StatusCreated)
    return
}
</code></pre>

<p>In line no. 2 we check whether the <code>Upload-Length</code> header is valid. If not we return a <code>Bad Request</code> response.</p>

<p>If the <code>Upload-Length</code> is valid, we create a file in the DB with the provided upload length and with initial <code>offset 0</code> and <code>upload complete false</code>. Then we create the file in the filesystem and return the location of the file in the <code>Location</code> http header and a <code>201 created</code> response code.</p>

<p>The <code>dirPath</code> field containing the path to store the file should be added to the <code>fileHandler</code> struct. This field will be updated with the dirPath returned from <code>createFileDir()</code> function later from <code>main()</code>. The updated <code>fileHandler</code> struct is provided below.</p>

<pre><code>type fileHandler struct {  
    db      *sql.DB
    dirPath string
}
</code></pre>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="headhttphandler">HEAD http handler</h3>

<p>When a HEAD request is received, we are supposed to return the offset of the file if it exists. If the file does not exist, then we should return a 404 not found response. We will name this handler as <code>fileDetailsHandler</code>.</p>

<pre><code class="language-go line-numbers">func (fh fileHandler) fileDetailsHandler(w http.ResponseWriter, r *http.Request) {  
    vars := mux.Vars(r)
    fID := vars["fileID"]
    file, err := fh.File(fID)
    if err != nil {
        w.WriteHeader(http.StatusNotFound)
        return
    }
    log.Println("going to write upload offset to output")
    w.Header().Set("Upload-Offset", strconv.Itoa(*file.offset))
    w.WriteHeader(http.StatusOK)
    return
}
</code></pre>

<p>We will use <a href="https://github.com/gorilla/mux" target="_"blank"">mux</a> router to route the http requests. Please run the command <code>go get github.com/gorilla/mux</code> to fetch the mux router from github.</p>

<p>In line no 3. we get the <code>fileID</code> from the request URL using <a href="https://github.com/gorilla/mux" target="_"blank"">mux</a> router. </p>

<p>For the purpose of understanding, I have provided the code which will call the above <code>fileDetailsHandler</code>. We will be writing the below line in the main function later. </p>

<pre><code class="language-go">r.HandleFunc("/files/{fileID:[0-9]+}", fh.fileDetailsHandler).Methods("HEAD")  
</code></pre>

<p>This handler will be called when the URL has a valid integer <code>fileID</code>. <code>[0-9]+</code> is a regular expression that matches one or more digits. If the <code>fileID</code> is valid, it will be stored with the key <code>fileID</code> in a map of type <code>map[string]string</code> . This map can be retrieved by calling the <code>Vars</code> function of the mux router. This is how we get the <code>fileID</code> in line no. 3.</p>

<p>After getting the <code>fileID</code>, we check whether the file exists by calling the <code>File</code>  method in line no. 4. Remember we wrote this <code>File</code> Method in the <a href="https://golangbot.com/resumable-file-uploader-implementing-db-crud-methods">last tutorial</a>. If the file is valid, we return the response with the <code>Upload-Offset</code> header. If not we return a <code>http.StatusNotFound</code> response.</p>

<h3 id="patchhttphandler">PATCH http handler</h3>

<p>The only remaining handler is the PATCH http handler. There are a few validations to be done in the <code>PATCH</code> request before we move to the actual file patching. Let's do them first.</p>

<h5 id="filevalidation">File validation</h5>

<p>The first step is to make sure the file trying to be uploaded actually exists.  </p>

<pre><code class="language-go line-numbers">func (fh fileHandler) filePatchHandler(w http.ResponseWriter, r *http.Request) {  
log.Println("going to patch file")  
    vars := mux.Vars(r)
    fID := vars["fileID"]
    file, err := fh.File(fID)
    if err != nil {
        w.WriteHeader(http.StatusNotFound)
        return
    }
}
</code></pre>

<p>The above code is similar to the one we wrote in the head http handler. It validates whether the file exists.</p>

<h5 id="uploadcompletevalidation">Upload complete validation</h5>

<p>The next step is to check whether the file has already been uploaded completely. </p>

<pre><code class="language-go line-numbers">if *file.uploadComplete == true {  
        e := "Upload already completed" //change to string
        w.WriteHeader(http.StatusUnprocessableEntity)
        w.Write([]byte(e))
        return
    }
</code></pre>

<p>If the upload is already complete, we return a <code>StatusUnprocessableEntity</code> status.</p>

<h5 id="uploadoffsetvalidation">Upload offset validation</h5>

<p>Each patch request should contain a <code>Upload-Offset</code> header field indicating the current offset of the data and the actual data to be patched to the file should be present in the message body.  </p>

<pre><code class="language-go line-numbers">off, err := strconv.Atoi(r.Header.Get("Upload-Offset"))  
if err != nil {  
    log.Println("Improper upload offset", err)
    w.WriteHeader(http.StatusBadRequest)
    return
}
log.Printf("Upload offset %d\n", off)  
if *file.offset != off {  
    e := fmt.Sprintf("Expected Offset %d got offset %d", *file.offset, off) 
    w.WriteHeader(http.StatusConflict)
    w.Write([]byte(e))
    return
}
</code></pre>

<p>In the above code, we first check whether the <code>Upload-Offset</code> in the request header is valid. If it is not, we return a <code>StatusBadRequest</code>.</p>

<p>In line no. 8, we compare the offset in the table <code>*file.Offset</code> with the one present in the header <code>off</code>. They are expected to be equal. <em>Let's take the example of a  file with upload length 250 bytes. If 100 bytes are already uploaded, the upload offset in the database will be 100. Now the server will expect a request with <code>Upload-offset</code> header 100.</em> If they are not equal, we return a <code>StatusConflict</code> header.</p>

<h5 id="contentlengthvalidation">Content length validation</h5>

<p>The next step is validating the <code>content-length</code>.</p>

<pre><code class="language-go line-numbers">clh := r.Header.Get("Content-Length")  
cl, err := strconv.Atoi(clh)  
if err != nil {  
    log.Println("unknown content length")
    w.WriteHeader(http.StatusInternalServerError)
    return
}

if cl != (file.uploadLength - *file.offset) {  
    e := fmt.Sprintf("Content length doesn't not match upload length.Expected content length %d got %d", file.uploadLength-*file.offset, cl)
    log.Println(e)
    w.WriteHeader(http.StatusBadRequest)
    w.Write([]byte(e))
    return
}
</code></pre>

<p>Let's say a file is 250 bytes length and the current offset is 150. This indicates that there are 100 more bytes to be uploaded. Hence the <code>Content-Length</code> of the patch request should be exactly 100. This validation is done in line no. 9 of the above code.</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h5 id="filepatch">File patch</h5>

<p>Now comes the fun part. We have done all our validations and ready to patch the file.</p>

<pre><code class="language-go line-numbers">body, err := ioutil.ReadAll(r.Body)  
if err != nil {  
    log.Printf("Received file partially %s\n", err)
    log.Println("Size of received file ", len(body))
}
fp := fmt.Sprintf("%s/%s", fh.dirPath, fID)  
f, err := os.OpenFile(fp, os.O_APPEND|os.O_WRONLY, 0644)  
if err != nil {  
    log.Printf("unable to open file %s\n", err)
    w.WriteHeader(http.StatusInternalServerError)
    return
}
defer f.Close()

n, err := f.WriteAt(body, int64(off))  
if err != nil {  
    log.Printf("unable to write %s", err)
    w.WriteHeader(http.StatusInternalServerError)
    return
}
log.Println("number of bytes written ", n)  
no := *file.offset + n  
file.offset = &amp;no

uo := strconv.Itoa(*file.offset)  
w.Header().Set("Upload-Offset", uo)  
if *file.offset == file.uploadLength {  
    log.Println("upload completed successfully")
    *file.uploadComplete = true
}

err = fh.updateFile(file)  
if err != nil {  
    log.Println("Error while updating file", err)
    w.WriteHeader(http.StatusInternalServerError)
    return
}
log.Println("going to send succesfully uploaded response")  
w.WriteHeader(http.StatusNoContent)  
</code></pre>

<p>We start reading the message body in line no.1 of the above code. The <code>ReadAll</code> function returns the data it has read until <code>EOF</code> or there is an error. <code>EOF</code> is not considered as an error as <code>ReadAll</code> is expected to read from the source until EOF. </p>

<p>Let's say the patch request disconnects before it is complete. When this happens, <code>ReadAll</code> will return a <code>unexpected EOF</code> error. <strong>Usually generic web servers will discard the request if it is incomplete. But we are creating a resumable file uploader and we shouldn't do it. We should patch the file with the data we have received till now.</strong> </p>

<p>The length of data received is printed in line no. 4.</p>

<p>In line no. 7 we open the file in append mode if it already exists or create a new file if it doesn't exist. </p>

<p>In line no. 15 we write the request body to the file at the offset provided in the request header. In line no. 23 we update the offset of the file by adding the number of bytes written. In line no. 26 we write the updated offset to the response header. </p>

<p>In line no. 27 we check whether the current offset is equal to the upload lenght. If this is the case then the upload has completed. We set the <code>uploadComplete</code> flag to <code>true</code>. </p>

<p>Finally in line no. 32 we write the updated file details to the database and return a <code>StatusNoContent</code> header indicating that the request is successful.</p>

<p>The entire code along with the main function available in github at <a href="https://github.com/golangbot/tusserver" target="_"blank"">https://github.com/golangbot/tusserver</a>. We will need the Postgres driver to run the code. Please fetch the postgres driver running the command <code>go get github.com/lib/pq</code> in the terminal before running the program.</p>

<p>That's about it. We have a working resumable file uploader. In the next tutorial, we will test this uploader using curl and dd commands and also discuss the possible enhancements.</p>

<p><strong>Next tutorial - <a href="https://golangbot.com/resumable-file-uploader-testing-the-server-using-curl-dd">Testing the server using curl and dd  commands</a></strong></p>

<p>Have a good day.</p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>]]></content:encoded></item><item><title><![CDATA[Resumable file uploader: Implementing DB CRUD methods]]></title><description><![CDATA[This tutorial deals with the creation of the DB CRUD methods needed for the resumable file upload tus server in Go. We will use PostgreSQL as the database.]]></description><link>https://golangbot.com/resumable-file-uploader-implementing-db-crud-methods/</link><guid isPermaLink="false">8723a968-2815-4f42-ab3c-f5db112f9af0</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Thu, 17 Jun 2021 00:59:00 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 2 in our <a href="https://golangbot.com/resumable-file-uploader/">Resumable file uploader series</a>.</p>

<p>The <a href="https://golangbot.com/understanding-tus">last tutorial</a> explained how tus protocol works. I strongly recommend reading the <a href="https://golangbot.com/understanding-tus">previous tutorial</a> if you are new to tus. In this tutorial, we will create the data model and the database CRUD methods.</p>

<p>This tutorial has the following sections</p>

<ul>
<li>Data model</li>
<li>Table creation</li>
<li>Tus Recollection</li>
<li>Creating file</li>
<li>Updating file</li>
<li>Get file</li>
</ul>

<h3 id="datamodel">Data model</h3>

<p>Let's first discuss the data model for our tus server. We will be using PostgreSQL as the database. </p>

<p>Our tus server needs a table <code>file</code> to store information related to a file. Let's discuss what fields should be in that table. </p>

<p>We need a field to uniquely identify files. To keep things simple, we will use an auto incremented <code>integer</code> field <code>field_id</code> as the file identifier. This field will be the primary key of the table. We will also use this id as the file name.</p>

<p>Next our server needs to keep track of the offset for each file. We will use an <code>integer</code> field <code>field_offset</code> to store the file offset. We will use another <code>integer</code> field <code>file_upload_length</code> to store the upload length of the file.</p>

<p>A boolean field  <code>file_upload_complete</code> is used to determine whether the entire file has been uploaded or not.</p>

<p>We will also have the usual audit fields <code>created_at</code> and <code>modified_at</code></p>

<p>Here is the table schema</p>

<pre><code>file_id SERIAL PRIMARY KEY  
file_offset INT NOT NULL  
file_upload_length INT NOT NULL  
file_upload_complete BOOLEAN NOT NULL  
created_at TIMESTAMP  default NOW() not null  
modified_at TIMESTAMP default NOW() not null  
</code></pre>

<h3 id="tablecreation">Table creation</h3>

<p>We will first create a database named <code>fileserver</code> and then write code to create the <code>file</code> table. </p>

<p>Please switch to the <code>psql</code> prompt in terminal using the following command</p>

<pre><code>$ \psql -U postgres
</code></pre>

<p>You will be prompted to enter the password. After successful login, you can view the Postgres command prompt.</p>

<pre><code>postgres=# create database fileserver;  
</code></pre>

<p>The above command will create the database <code>fileserver</code></p>

<p>Now that we have the DB ready, let's go ahead and create the table in code.</p>

<pre><code class="language-go line-numbers">type fileHandler struct {  
    db *sql.DB
}

func (fh fileHandler) createTable() error {  
    q := `CREATE TABLE IF NOT EXISTS file(file_id SERIAL PRIMARY KEY, 
           file_offset INT NOT NULL, file_upload_length INT NOT NULL, file_upload_complete BOOLEAN NOT NULL, 
          created_at TIMESTAMP default NOW() NOT NULL, modified_at TIMESTAMP default NOW() NOT NULL)`
    _, err := fh.db.Exec(q)
    if err != nil {
        return err
    }
    log.Println("table create successfully")
    return nil
}
</code></pre>

<p>We have a <code>fileHandler</code> struct which contains a single field <code>db</code> which is the handle to the database. This will be injected from main later. In line no. 5 we have added the <code>createTable()</code> method. This <a href="https://golangbot.com/methods/">method</a> creates the table if it does not exist and returns errors if any.</p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="tusrecollection">Tus Recollection</h3>

<p>Before we create the DB CRUD methods, let's recollect the http methods used by the <a href="https://golangbot.com/understanding-tus">tus</a> protocol</p>

<p><strong>POST</strong> - To create a new file</p>

<p><strong>PATCH</strong> - To upload data to an existing file at offset <code>Upload-Offset</code></p>

<p><strong>HEAD</strong> - To get the current <code>Upload-Offset</code> of the file to start the next patch request from.</p>

<p>We will need the Create, Update and Read table operations to support the above http methods. We will create them in this tutorial.</p>

<h3 id="creatingfile">Creating file</h3>

<p>Before we add the method to create the file, let's go ahead and define the file data structure first.</p>

<pre><code class="language-go line-numbers">type file struct {  
    fileID         int
    offset         *int
    uploadLength   int
    uploadComplete *bool
}
</code></pre>

<p>The <code>file</code> struct above represents a file. Its fields are self explanatory. There is a reason why we have chosen pointers types for <code>offset</code> and <code>uploadLength</code> and will be explained later.</p>

<p>We will next add the method to insert a new row into the <code>file</code> table.</p>

<pre><code class="language-go line-numbers">func (fh fileHandler) createFile(f file) (string, error) {  
    cfstmt := `INSERT INTO file(file_offset, file_upload_length, file_upload_complete) VALUES($1, $2, $3) RETURNING file_id`
    fileID := 0
    err := fh.db.QueryRow(cfstmt, f.offset, f.uploadLength, f.uploadComplete).Scan(&amp;fileID)
    if err != nil {
        return "", err
    }
    fid := strconv.Itoa(fileID)
    return fid, nil   
}
</code></pre>

<p>The above method inserts a row into the <code>file</code> table and converts the <code>fileID</code> to string and returns it. It's pretty straightforward. The reason we are converting the <code>fileID</code> to <code>string</code> is because the fileID is also used as the name of the file later.</p>

<h3 id="updatingfile">Updating file</h3>

<p>Let's write the file update method now. In a typical file, we only ever have to update the <code>offset</code> and <code>uploadComplete</code> fields of a file. The <code>fileID</code> and the <code>uploadLength</code> will not change once a file is created. This is also the reason we choose pointers for <code>offset</code> and <code>uploadComplete</code> in the <code>file</code> struct. If <code>offset</code> or <code>uploadComplete</code> is <code>nil</code>, it means that these fields are not set and need not be updated. <em>If we would have chosen value types instead of pointer types for these two fields, if they are not present, still those fields would have their corresponding zero values of <code>0</code> and <code>false</code> and we will have no way to find out whether they were actually set or not.</em></p>

<p>The file update method is provided below.</p>

<pre><code class="language-go line-numbers">func (fh fileHandler) updateFile(f file) error {  
    var query []string
    var param []interface{}
    if f.offset != nil {
        of := fmt.Sprintf("file_offset = $1")
        ofp := f.offset
        query = append(query, of)
        param = append(param, ofp)
    }
    if f.uploadComplete != nil {
        uc := fmt.Sprintf("file_upload_complete = $2")
        ucp := f.uploadComplete
        query = append(query, uc)
        param = append(param, ucp)
    }

    if len(query) &gt; 0 {
        mo := "modified_at = $3"
        mop := "NOW()"

        query = append(query, mo)
        param = append(param, mop)

        qj := strings.Join(query, ",")

        sqlq := fmt.Sprintf("UPDATE file SET %s WHERE file_id = $4", qj) 

        param = append(param, f.fileID)

        log.Println("generated update query", sqlq)
        _, err := fh.db.Exec(sqlq, param...) 

        if err != nil {
            log.Println("Error during file update", err)
            return err
        }
    }
    return nil
}
</code></pre>

<p>Let me brief how this method works. We have two slices <code>query</code> and <code>param</code> defined in line nos. 2 and 3. We will be appending the update queries to the <code>query</code> slice and the corresponding arguments in the <code>params</code> slice. Finally, we will create the update query using the contents of these two slices.</p>

<p>In line no. 4 we check whether offset is <code>nil</code>. If not we add the corresponding update statement to the <code>query</code> slice and the argument to the <code>param</code> slice. We apply similar logic for <code>uploadComplete</code> in line no. 10.</p>

<p>In line no. 17, we check whether the length of <code>query</code> is greater than zero. If it is true, it means that we have a field to be updated. In line no. 18, we then add the query and fields to update the <code>modified_at</code> DB field.</p>

<p>Line no.24 joins the contents of the <code>query</code> slice to create the query.</p>

<p>Let's try to better understand this code using a <code>file</code> struct with <code>fileID 32,  offset 100 and uploadComplete false</code>.</p>

<p>The contents of the <code>query</code> and <code>param</code> slice at line no. 17 will be</p>

<pre><code>query = []string{"file_offset = $1", "file_upload_complete = $2"}  
params = []interface{}{100, false}  
</code></pre>

<p>The generated update query in line no. 30 will be of the form</p>

<pre><code>UPDATE file SET file_offset = $1, file_upload_complete = $2, modified_at = $3 WHERE file_id = $4  
</code></pre>

<p>and the final <code>param</code> slice will be <code>{100, false, NOW(), 32}</code></p>

<p>We execute the query in line no. 31 and return errors if any. </p>

<h3 id="getfile">Get file</h3>

<p>The final DB method needed by the tus protocol is a method to return the details of a file when provided with a <code>fileID</code>.</p>

<pre><code class="language-go line-numbers">func (fh fileHandler) File(fileID string) (file, error) {  
    fID, err := strconv.Atoi(fileID)
    if err != nil {
        log.Println("Unable to convert fileID to string", err)
        return file{}, err
    }
    log.Println("going to query for fileID", fID)
    gfstmt := `select file_id, file_offset, file_upload_length, file_upload_complete from file where file_id = $1`
    row := fh.db.QueryRow(gfstmt, fID)
    f := file{}
    err = row.Scan(&amp;f.fileID, &amp;f.offset, &amp;f.uploadLength, &amp;f.uploadComplete)
    if err != nil {
        log.Println("error while fetching file", err)
        return file{}, err
    }
    return f, nil
}
</code></pre>

<p>In the above method, we return the details of the file when provided with a <code>fileID</code>. It's straightforward.</p>

<p>Now that we are done with the DB methods, the next step would be to create the http handlers. We will do this in the next tutorial.</p>

<p><strong>Next tutorial - <a href="https://golangbot.com/resumable-file-uploader-creating-http-handlers">Creating http handlers</a></strong></p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>]]></content:encoded></item><item><title><![CDATA[Resumable file uploader: Understanding tus protocol]]></title><description><![CDATA[This tutorial explains how  tus protocol works and how it can be used to create a resumable file uploader in Go.]]></description><link>https://golangbot.com/understanding-tus/</link><guid isPermaLink="false">755f4cee-16a3-4365-939a-1a6270615237</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Sat, 19 Jun 2021 00:26:00 GMT</pubDate><content:encoded><![CDATA[<p>Welcome to tutorial no. 1 in our <a href="https://golangbot.com/resumable-file-uploader/">Resumable file uploader series</a>.</p>

<p>How many times have you tried to upload a large file only to know that it failed because of a network issue! When you re-upload the file again, the upload starts from the beginning :(. Not cool at all. This is where resumable file uploaders come in handy. </p>

<p><strong>Resumable file uploaders allow the file upload to start right from the point where it stopped instead of uploading the whole file again.</strong></p>

<p>In this tutorial series we will learn how to create a resumable file upload server and client in Go using the <a href="https://tus.io" target="_"blank"">tus protocol</a>. This tutorial is not an exact implementation of the tus protocol, but rather a simplified version. This tutorial is self-sufficient to create a resumable file uploader using Go. We will keep improving this uploader in the upcoming tutorials and make it full tus compatible.</p>

<p>This tutorial has the following sections</p>

<ul>
<li>Tus protocol </li>
<li>POST request to create the file</li>
<li>PATCH request to update the file</li>
<li>HEAD request to get the current file offset</li>
</ul>

<h3 id="tusprotocol">Tus protocol</h3>

<p>The tus protocol is quite simple and the best selling point of tus is that it works on top of HTTP. Let's first understand how tus protocol works. </p>

<p>Tus protocol needs three http methods namely POST, PATCH and HEAD. It's best to understand the tus protocol using an example. </p>

<p>Let's take the example of uploading a file of size 250 bytes. The upcoming sections explain the sequence of http calls required to upload a file using tus protocol.</p>

<h4 id="postrequesttocreatethefile">POST request to create the file</h4>

<p>This is the first step. The client sends a <code>POST</code> request with the file's upload length(size) to the server. The server creates a new file and responds with the file's location.</p>

<p><strong>Request</strong></p>

<pre><code>POST /files HTTP/1.1  
Host: localhost:8080  
Content-Length: 0  
Upload-Length: 250  
</code></pre>

<p>In the above request, we send a POST request to the URL <code>localhost:8080/files</code> to create a file with <code>Upload-length</code> 250 bytes. The <code>Upload-length</code> represents the size of the entire file. Since the request does not have a message body, the <code>Content-Length</code> field is zero.</p>

<p>The server creates the file and returns the following response.</p>

<p><strong>Response</strong></p>

<pre><code>HTTP/1.1 201 Created  
Location: localhost:8080/files/12  
</code></pre>

<p>The <code>Location</code> header provides the location of the created file. In our case, it is <code>localhost:8080/files/12</code></p>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h4 id="patchrequesttoupdatethefile">PATCH request to update the file</h4>

<p>Patch request is used to write bytes to the file at offset <code>Upload-Offset</code>. Each patch request should contain a <code>Upload-Offset</code> field indicating the current offset of the file data being uploaded.</p>

<p>In our case, since we just created a new file and starting to upload data to the file, the client sends a <code>PATCH</code> request with <code>Upload-Offset</code> as 0. <strong>Please note that file offsets are zero based. The first byte of the file is at offset 0.</strong></p>

<p><strong>Request</strong></p>

<pre><code>PATCH /files/12 HTTP/1.1  
Host: localhost:8080  
Content-Length: 250  
Upload-Offset: 0

[250 bytes of the file]
</code></pre>

<p>In the above request, the <code>Content-Length</code> field is 250 since we are uploading a file of size 250 bytes. The <code>Upload-Offset</code> is 0 indicating that the server should write the contents of the request at byte 1 of the file.</p>

<p>The server will respond with a <code>204 No Content</code> header indicating the request is successful. Response to the <code>PATCH</code> request should contain the <code>Upload-Offset</code> field indicating the next byte to be uploaded. In this case, the  <code>Upload-Offset</code> field will be <code>250</code> indicating that the server has received the entire file and the upload is complete. </p>

<p><strong>Response</strong></p>

<pre><code>HTTP/1.1 204 No Content  
Upload-Offset: 250  
</code></pre>

<p>The above response from the server indicates that the upload has completed successfully since the <code>Upload-Offset</code> is equal to the <code>Upload-Length 250</code>.</p>

<h4 id="headrequesttogetthecurrentfileoffset">HEAD request to get the current file offset</h4>

<p>The patch request above was completed successfully without any network problems and the file was uploaded completely.</p>

<p>What if there was a network issue while the file was being uploaded and the upload failed in the middle. The client should not upload the entire file again but rather start uploading the file from the failed byte. This is where the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" target="_"blank"">HEAD</a> request helps. </p>

<p>Let's say the file upload request disconnected after uploading <code>100</code> bytes. The client needs to send a <code>HEAD</code> request to the server to get the current <code>Upload-Offset</code> of the file to know how many bytes have been uploaded and how much is still left to be uploaded. </p>

<p><strong>Request</strong></p>

<pre><code>HEAD /files/12 HTTP/1.1  
Host: localhost:8080  
</code></pre>

<p><strong>Response</strong></p>

<pre><code>HTTP/1.1 200 OK  
Upload-Offset: 100  
</code></pre>

<p>The server responds with the upload offset 100 indicating that the client has to start uploading again from the offset 100. Note that the response to a head request does not contain a message body. It only contains a header. </p>

<p>The client sends a PATCH request with this upload offset and request body containing the remaining 150 bytes </p>

<p><em>250(file size) - 100(upload offset) = 150 remaining bytes</em></p>

<p><strong>Request</strong></p>

<pre><code>PATCH /files/12 HTTP/1.1  
Host: localhost:8080  
Content-Length: 150  
Upload-Offset: 100

[Remaining 150 bytes]
</code></pre>

<p><strong>Response</strong></p>

<pre><code>HTTP/1.1 204 No Content  
Upload-Offset: 250  
</code></pre>

<p>The server responds with a <code>204</code> status and <code>Upload-Offset: 250</code>  equal to <code>Upload-Length</code> indicating the file upload has been uploaded completely. </p>

<p>In case the request again fails in the middle during upload, the client should send a <code>HEAD</code> request followed by <code>PATCH</code>. </p>

<p><strong>The gist is to keep calling <code>HEAD</code> to know the current <code>Upload-Offset</code> followed by <code>PATCH</code> until the server responds with a <code>Upload-Offset</code> equal to <code>Upload-Length</code>.</strong></p>

<p>This brings us to the end of this tutorial. In the next tutorial, we will create the data model for the tus server. Have a good day.</p>

<p><strong>Next tutorial - <a href="https://golangbot.com/resumable-file-uploader-implementing-db-crud-methods">Implementing DB CRUD methods</a></strong></p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>]]></content:encoded></item><item><title><![CDATA[Writing Files using Go]]></title><description><![CDATA[This tutorial teaches how to write strings and bytes to a file using Go. It also deals with file append and concurrent writes to a file.]]></description><link>https://golangbot.com/write-files/</link><guid isPermaLink="false">4e78f11e-66bc-4459-95a0-606b448b7a2d</guid><dc:creator><![CDATA[Naveen Ramanathan]]></dc:creator><pubDate>Thu, 20 May 2021 14:52:00 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://golangbot.com/content/images/2018/12/golang-write-files.png" alt=""></p>

<p>Welcome to tutorial no. 36 in <a href="https://golangbot.com/learn-golang-series/">Golang tutorial series</a>.</p>

<p>In this tutorial, we will learn how to write data to files using Go. We will also learn how to write to a file concurrently.</p>

<p>This tutorial has the following sections</p>

<ul>
<li>Writing string to a file</li>
<li>Writing bytes to a file</li>
<li>Writing data to a file line by line </li>
<li>Appending to a file</li>
<li>Writing to a file concurrently</li>
</ul>

<p>Please run all the programs of this tutorial in your local system as playground doesn't support file operations.</p>

<h3 id="writingstringtoafile">Writing string to a file</h3>

<p>One of the most common file writing operations is writing a string to a file. This is quite simple to do. It consists of the following steps.</p>

<ol>
<li>Create the file  </li>
<li>Write the string to the file</li>
</ol>

<p>Let's get to the code right away.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "os"
)

func main() {  
    f, err := os.Create("test.txt")
    if err != nil {
        fmt.Println(err)
        return
    }
    l, err := f.WriteString("Hello World")
    if err != nil {
        fmt.Println(err)
        f.Close()
        return
    }
    fmt.Println(l, "bytes written successfully")
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
}
</code></pre>

<p>The <code>create</code> function in line no. 9 of the program above creates a file named <em>test.txt</em>. If a file with that name already exists, then the create function truncates the file. This function returns a <a href="https://golang.org/pkg/os/#File" target="_"blank"">File descriptor</a>.</p>

<p>In line no 14, we write the string <strong>Hello World</strong> to the file using the <code>WriteString</code> method. This method returns the number of bytes written and error if any.</p>

<p>Finally, we close the file in line no. 21.</p>

<p>The above program will print</p>

<pre><code>11 bytes written successfully  
</code></pre>

<p>You can find a file named <strong>test.txt</strong> created in the directory from which this program was executed. If you open the file using any text editor, you can find that it contains the text <strong>Hello World</strong>.</p>

<h3 id="writingbytestoafile">Writing bytes to a file</h3>

<p>Writing bytes to a file is quite similar to writing a string to a file. We will use the <a href="https://golang.org/pkg/os/#File.Write" target="_"blank"">Write</a> method to write bytes to a file. The following program writes a slice of bytes to a file.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "os"
)

func main() {  
    f, err := os.Create("/home/naveen/bytes")
    if err != nil {
        fmt.Println(err)
        return
    }
    d2 := []byte{104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100}
    n2, err := f.Write(d2)
    if err != nil {
        fmt.Println(err)
        f.Close()
        return
    }
    fmt.Println(n2, "bytes written successfully")
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
}
</code></pre>

<p>In the program above, in line no. 15 we use the <strong>Write</strong> method to write a slice of bytes to a file named <code>bytes</code> in the directory <code>/home/naveen</code>. You can change this directory to a different one. The remaining program is self-explanatory. This program will print <code>11 bytes written successfully</code> and it will create a file named <code>bytes</code>. Open the file and you can see that it contains the text <code>hello bytes</code></p>

<h3 id="writingstringslinebylinetoafile">Writing strings line by line to a file</h3>

<p>Another common file operation is the need to write strings to a file line by line. In this section, we will write a program to create a file with the following content.</p>

<pre><code>Welcome to the world of Go.  
Go is a compiled language.  
It is easy to learn Go.  
</code></pre>

<p>Let's get to the code right away.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "os"
)

func main() {  
    f, err := os.Create("lines")
    if err != nil {
        fmt.Println(err)
                f.Close()
        return
    }
    d := []string{"Welcome to the world of Go1.", "Go is a compiled language.", "It is easy to learn Go."}

    for _, v := range d {
        fmt.Fprintln(f, v)
        if err != nil {
            fmt.Println(err)
            return
        }
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("file written successfully")
}
</code></pre>

<p>In line no.9 of the program above, we create a new file named <strong>lines</strong>. In line no. 17 we iterate through the array using a for range loop and use the <a href="https://golang.org/pkg/fmt/#Fprintln" target="_"blank"">Fprintln</a> function to write the lines to a file. The <strong>Fprintln</strong> function takes a io.writer as parameter and appends a new line, just what we wanted. Running this program will print <code>file written successfully</code> and a file <code>lines</code> will be created in the current directory. The content of the file <code>lines</code> is provided below.</p>

<pre><code>Welcome to the world of Go1.  
Go is a compiled language.  
It is easy to learn Go.  
</code></pre>

<p><center> <br>
<script type="text/javascript" src="//static.mailerlite.com/data/webforms/524571/p8t5t8.js?v4"></script></center><br></p>

<h3 id="appendingtoafile">Appending to a file</h3>

<p>In this section, we will append one more line to the <code>lines</code> file which we created in the previous section. We will append the line <strong>File handling is easy</strong> to the <code>lines</code> file. </p>

<p>The file has to be opened in append and write only mode. These flags are passed parameters are passed to the <a href="https://golang.org/pkg/os/#OpenFile" target="_"blank"">Open</a> function. After the file is opened in append mode, we add the new line to the file. </p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "os"
)

func main() {  
    f, err := os.OpenFile("lines", os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Println(err)
        return
    }
    newLine := "File handling is easy."
    _, err = fmt.Fprintln(f, newLine)
    if err != nil {
        fmt.Println(err)
                f.Close()
        return
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("file appended successfully")
}
</code></pre>

<p>In line no. 9 of the program above, we open the file in append and write only mode. After the file is opened successfully, we add a new line to the file in line no. 15. This program will print <code>file appended successfully</code>. After running this program, the contents of the <code>lines</code> file will be,</p>

<pre><code>Welcome to the world of Go1.  
Go is a compiled language.  
It is easy to learn Go.  
File handling is easy.  
</code></pre>

<h3 id="writingtofileconcurrently">Writing to file concurrently</h3>

<p>When multiple goroutines write to a file concurrently, we will end up with a <a href="https://golangbot.com/mutex/#criticalsection">race condition</a>. Hence concurrent writes to a file should be coordinated using a channel. </p>

<p>We will write a program that creates 100 goroutines. Each of this goroutine will generate a random number concurrently, thus generating hundred random numbers in total.  These random numbers will be written to a file. We will solve this problem by using the following approach.</p>

<ol>
<li>Create a channel that will be used to read and write the generated random numbers.  </li>
<li>Create 100 producer goroutines. Each goroutine will generate a random number and will also write the random number to a channel.  </li>
<li>Create a consumer goroutine that will read from the channel and write the generated random number to the file. Thus we have only one goroutine writing to a file concurrently thereby avoiding race condition :)  </li>
<li>Close the file once done.</li>
</ol>

<p>Let's write the <code>produce</code> function first which generates the random numbers.</p>

<pre><code class="language-go line-numbers">func produce(data chan int, wg *sync.WaitGroup) {  
    n := rand.Intn(999)
    data &lt;- n
    wg.Done()
}
</code></pre>

<p>The function above generates a random number and writes it to the channel <code>data</code> and then calls <code>Done</code> on the <a href="https://golangbot.com/buffered-channels-worker-pools/#waitgroup">waitgroup</a> to notify that it is done with its task.</p>

<p>Let's move to the function which writes to the file now.</p>

<pre><code class="language-go line-numbers">func consume(data chan int, done chan bool) {  
    f, err := os.Create("concurrent")
    if err != nil {
        fmt.Println(err)
        return
    }
    for d := range data {
        _, err = fmt.Fprintln(f, d)
        if err != nil {
            fmt.Println(err)
            f.Close()
            done &lt;- false
            return
        }
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        done &lt;- false
        return
    }
    done &lt;- true
}
</code></pre>

<p>The <code>consume</code> function creates a file named <code>concurrent</code>. It then reads the random numbers from the <code>data</code> channel and writes to the file. Once it has read and written all the random numbers, it writes <code>true</code> to the <code>done</code> channel to notify that it's done with its task.</p>

<p>Let's write the <code>main</code> function and complete this program. I have provided the entire program below.</p>

<pre><code class="language-go line-numbers">package main

import (  
    "fmt"
    "math/rand"
    "os"
    "sync"
)

func produce(data chan int, wg *sync.WaitGroup) {  
    n := rand.Intn(999)
    data &lt;- n
    wg.Done()
}

func consume(data chan int, done chan bool) {  
    f, err := os.Create("concurrent")
    if err != nil {
        fmt.Println(err)
        return
    }
    for d := range data {
        _, err = fmt.Fprintln(f, d)
        if err != nil {
            fmt.Println(err)
            f.Close()
            done &lt;- false
            return
        }
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
        done &lt;- false
        return
    }
    done &lt;- true
}

func main() {  
    data := make(chan int)
    done := make(chan bool)
    wg := sync.WaitGroup{}
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go produce(data, &amp;wg)
    }
    go consume(data, done)
    go func() {
        wg.Wait()
        close(data)
    }()
    d := &lt;-done
    if d == true {
        fmt.Println("File written successfully")
    } else {
        fmt.Println("File writing failed")
    }
}
</code></pre>

<p>The main function creates the <code>data</code> channel in line no. 41 from which random numbers are read from and written. The <code>done</code> channel in line no. 42 is used by the <code>consume</code> goroutine to notify <code>main</code> that it is done with its task. The <code>wg</code> waitgroup in line no. 43 is used to wait for all the 100 goroutines to finish generating random numbers.</p>

<p>The <code>for</code> loop in line no. 44 creates 100 goroutines. The goroutine call in line no. 49 calls <code>wait()</code> on the waitgroup to wait for all 100 goroutines to finish creating random numbers. After that, it closes the channel. Once the channel is closed and the <code>consume</code> goroutine has finished writing all generated random numbers to the file, it writes <code>true</code> to the <code>done</code> channel in line no. 37 and the main goroutine is unblocked and prints <code>File written successfully</code>.</p>

<p>Now you can open the file <strong>concurrent</strong> in any text editor and see the 100 generated random numbers :)</p>

<p>This brings us to the end of this tutorial. Hope you enjoyed reading. Have a great day.</p>

<p>Like my tutorials? Please show your support by <a href="https://golangbot.com/support-the-content/">donating</a>. Your donations will help me create more awesome tutorials. </p>

<p>Previous tutorial - <a href="https://golangbot.com/read-files/">Reading Files</a></p>]]></content:encoded></item></channel></rss>